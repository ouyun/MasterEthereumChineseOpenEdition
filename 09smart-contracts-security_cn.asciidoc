[[smart_contract_security]]
== 智能合约的安全问题

((("security (smart contracts)", id="ix_09smart-contracts-security-asciidoc0", range="startofrange")))((("smart contracts","security", id="ix_09smart-contracts-security-asciidoc1", range="startofrange")))安全是编写智能合约时最重要的考虑因素之一。在智能合约编程领域，错误代价高昂且容易被利用。在本章中，我们将研究安全的最佳实践和设计模式，以及“不安全模式”，这些实践和模式会在我们的智能合约中引入漏洞。

与其他程序一样，智能合约将完全执行所编写的内容，而这并不总是程序员想要的。此外，所有智能合约都是公开的，任何用户都可以通过创建交易轻松地操作它们。这也会导致任何漏洞都会被发现，并且几乎总是无法挽回损失。因此，遵循最佳实践并使用经过良好测试的设计模式至关重要。

=== 安全的最佳实践

((("defensive programming")))((("security (smart contracts)","best practices")))_防御性编程_ 是一种非常适合于智能合约的编程方式。它强调以下所有最佳实践：

极简/简单:: 复杂性是安全的大敌。代码越简单，作用越少，发生错误或无法预料的影响的机会就越小。刚开始进行智能合约编程时，开发人员通常会尝试编写大量代码。相反，你应该浏览智能合约代码，并尝试找到减少代码行数，减少复杂性和减少“功能”的方法。如果有人告诉你他们的项目已经为他们的智能合约生成了“数千行代码”，那么你应该质疑该项目的安全性。越简单越安全。

代码重用:: 尽量不要重新发明轮子。如果已经存在满足你大部分需求的库或合约，请重新使用它。在你自己的代码中，遵循DRY原则：不要重复自己（Don't Repeat Yourself）。如果你看到任何重复的代码片段都不止一次，请问自己是否可以将其编写为函数或库并重新使用。经过广泛使用和测试的代码可能比你编写的任何新代码更安全。谨防“Not Invented Here”综合症，在这种情况下，你很容易通过从头开始构建来“改进”功能或组件。安全风险通常大于改进的价值。

代码质量:: 智能合约代码一旦部署是不可撤回的。每个错误都可能导致金钱损失。你不应将智能合约编程与通用编程一样对待。以Solidity编写DApp不同于使用JavaScript创建Web小部件。相反，你应该应用严格的工程和软件开发方法，就像在航空工程或任何类似的严酷学科中一样。一旦“启动”你的代码，你无法修复任何问题。

可读性/可审计性:: 你的代码应清晰易懂。越容易阅读就越容易审核。智能合约是公开的，因为每个人都可以读取字节码，任何人都可以对其进行逆向编译。因此，使用协作和开放源代码方法在公共环境下开发你的工作，利用开发人员社区的集体智慧并受益于开放源代码开发的最高共同点是有益的。你应该遵循以太坊社区中的样式和命名约定，编写有据可查且易于阅读的代码。

测试覆盖:: 尽可能测试所有内容。智能合约在公共执行环境中运行，任何人都可以在任何需要的输入下执行它们。你永远不要假设输入例如函数参数格式正确，有界或有良性目的。在允许继续执行代码之前，请测试所有参数以确保它们在预期范围内并且格式正确。

=== 安全风险和反制模式

((("security (smart contracts)","risks and antipatterns", id="ix_09smart-contracts-security-asciidoc2", range="startofrange")))作为智能合约程序员，你应该最熟悉常见的安全风险，以便能够检测和避免使你的合约面临这些风险的编程模式。在接下来的几节中，我们将研究不同的安全风险，漏洞如何产生的示例以及可以用来解决这些漏洞的对策或预防性解决方案。

[[reentrancy_security]]
=== 重入式攻击

((("reentrancy attacks", id="ix_09smart-contracts-security-asciidoc3", range="startofrange")))((("security (smart contracts)","reentrancy attacks", id="ix_09smart-contracts-security-asciidoc4", range="startofrange")))以太坊智能合约的功能之一是它们的调用和利用其他外部合约的能力。合约通常处理以太币，因此经常将以太币发送给各种外部用户地址。这些操作需要合约提交外部调用。这些外部调用可以被攻击者劫持，然后可以强迫合约执行其他代码（通过fallback函数），包括回调攻击者自己。这种攻击被用于臭名昭著的DAO攻击 http://bit.ly/2DamSZT[DAO hack]。

有关再入攻击的更多信息，请参阅Gus Guimareas关于该主题的博客 http://bit.ly/2zaqSEY[blog post] 和以太坊智能合约最佳实践 http://bit.ly/2ERDMxV[Ethereum Smart Contract Best Practices]。

[role="notoc"]
==== 漏洞
////
编者注
本章中的标题“漏洞”和“预防技术”已从标题更改为粗体格式，以免用重复的措辞使目录混乱。
////

((("reentrancy attacks","vulnerability", id="ix_09smart-contracts-security-asciidoc5", range="startofrange")))当合约将以太币发送到未知地址时，就会发生这种类型的攻击。攻击者可以在外部地址谨慎构建合约在回退函数中包含恶意代码。 因此，当合约将以太币发送到该地址时，它将调用恶意代码。 通常，恶意代码执行一个在易受攻击的合约上运行，执行开发者预期之外的操作。 “可重入性”一词源于这样一个事实：外部恶意合约调用易受攻击的函数合约和代码执行的路径“重新进入”它。

为了澄清这一点，请考虑<<etherstore_vulnerable>>，用作以太坊保险库，使存款人每人每周只能提取1个以太币。

[[etherstore_vulnerable]]
.EtherStore.sol
====
[source,solidity,linenums]
----
  1 contract EtherStore {
  2 
  3     uint256 public withdrawalLimit = 1 ether;
  4     mapping(address => uint256) public lastWithdrawTime;
  5     mapping(address => uint256) public balances;
  6 
  7     function depositFunds() external payable {
  8         balances[msg.sender] += msg.value;
  9     }
 10 
 11     function withdrawFunds (uint256 _weiToWithdraw) public {
 12         require(balances[msg.sender] >= _weiToWithdraw);
 13         // limit the withdrawal
 14         require(_weiToWithdraw <= withdrawalLimit);
 15         // limit the time allowed to withdraw
 16         require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
 17         require(msg.sender.call.value(_weiToWithdraw)());
 18         balances[msg.sender] -= _weiToWithdraw;
 19         lastWithdrawTime[msg.sender] = now;
 20     }
 21  }
----
====

该合约具有两个公共函数，即 `depositFunds` 和 `withdrawFunds`。`depositFunds` 函数简单地增加发送者的余额。`withdrawFunds` 函数使发送者能够指定提款额。此函数的设计是仅在要求的提款金额少于1个以太币且提款未在最近一周发生时才会成功。

漏洞在第17行中，合约将用户发送给他们请求的以太币数量。考虑一个攻击者创建了一个在<<etherstore_attack>>中的合约。

[[etherstore_attack]]
.Attack.sol
====
[source,solidity,linenums]
----
  1 import "EtherStore.sol";
  2 
  3 contract Attack {
  4   EtherStore public etherStore;
  5 
  6   // intialize the etherStore variable with the contract address
  7   constructor(address _etherStoreAddress) {
  8       etherStore = EtherStore(_etherStoreAddress);
  9   }
 10 
 11   function attackEtherStore() external payable {
 12       // attack to the nearest ether
 13       require(msg.value >= 1 ether);
 14       // send eth to the depositFunds() function
 15       etherStore.depositFunds.value(1 ether)();
 16       // start the magic
 17       etherStore.withdrawFunds(1 ether);
 18   }
 19 
 20   function collectEther() public {
 21       msg.sender.transfer(this.balance);
 22   }
 23 
 24   // fallback function - where the magic happens
 25   function () payable {
 26       if (etherStore.balance > 1 ether) {
 27           etherStore.withdrawFunds(1 ether);
 28       }
 29   }
 30 }
----
====

漏洞如何发生？首先，攻击者会创建恶意合约（例如，在地址 `0x0...123` ），其中使用作为 `EtherStore` 的合约地址为唯一的构造函数的地址。这样会初始化并将公共变量 `etherStore` 添加到要攻击的合约中。

然后，攻击者将调用 `attackEtherStore` 函数，其中包含一些大于或等于1的以太币&#x2014;目前暂时假设 `1以太` 。在此示例中，我们还将假设一些其他用户已经将以太币存入该合约，比如其当前余额为 `10个以太币` 。然后将发生以下情况：

1. _Attack.sol_，第15行：`EtherStore` 合约的 `depositFunds` 函数会按照1个以太币的msg.value参数值（和大量燃料）被调用。发起者（`msg.sender`）将是恶意合约（`0x0...123`）。从而导致：
    `balances[0x0..123] = 1 ether`.

2. _Attack.sol_，第17行：恶意合约将调用 `EtherStore` 合约的 `withdrawFunds` 函数，输入参数为1以太币。这将通过 `EtherStore` 合约12-16行的所有要求条件），因为之前没有提现过。

3. _EtherStore.sol_，第17行：合约会将 `1 ether` 发送回给恶意 pass:[<span class="keep-together">合约</span>]。

4. _Attack.sol_，第25行：向恶意合约付款会导致执行fallback函数。

5. _Attack.sol_，第26行： +EtherStore+ 合约的总余额之前为'10 ether' 现在是 '9 ether'，因此 +if+ 语句通过。

6. _Attack.sol_，第27行：fallback函数再次调用 `EtherStore` `withdrawFunds` 函数，使得  '_再次进入_' `EtherStore` 合约。

7. _EtherStore.sol_，第11行：在对 `withdrawFunds` 的第二次调用中，由于第18行尚未执行，攻击合约的余额仍为 `1 ether`。因此，我们仍然符合 `balances[0x0..123] = 1 ether` 的条件。这对于 `lastWithdrawTime` 变量也成立。同样，我们通过了所有要求。

8. _EtherStore.sol_，第17行：攻击合约提取了另外的 `1 ether`。

9. 重复步骤4至8，直到不再出现 `EtherStore.balance > 1`，如 _Attack.sol_ 中的第26行所指示。

10. _Attack.sol_，第26行：一旦 `EtherStore` 合约中剩下1（或更少）个以太币，此 `if` 语句将失败。然后，这将允许执行 `EtherStore` 合约的第18行和第19行（对于每次对 `withdrawFunds` 函数的调用）。

11. _EtherStore.sol_，第18和19行：`balances` 和 `lastWithdrawTime` 将建立映射，执行将结束。

最终结果是攻击者提取了除1个ether以外的所有以太币，而仅仅通过一次交易从 `EtherStore` 合约中获取的。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc5")))

[role="notoc"]
==== 预防技术

((("reentrancy attacks","preventative techniques")))有许多常见的技术可以帮助避免潜在的智能合约中的可重入漏洞。 ((("transfer function","to reduce reentrancy vulnerabilities")))首先是（尽可能）使用内置的 http://bit.ly/2Ogvnng[ +transfer+ ] 函数来向外部合约发送ether。+transfer+ 函数仅发送2300个gas，不够支撑目的地址/合约来调用另一个合约（比如重新进入一个发送合约）。

((("checks-effects-interactions pattern")))第二种技术是确保所有更改状态的逻辑变量在以太币被发送出合约之前发生（或任何其他外部调用）。在 `EtherStore` 示例中，第18行和第19行 _EtherStore.sol_ 应该放在第17行之前。一个好习惯是对于任何执行对未知地址的外部调用的代码，都将其作为本地函数或一段代码执行中的最后一个操作。这个被称为 http://bit.ly/2EVo70v[checks-effects-interactions pattern].

((("mutex")))第三种技术是引入互斥量&#x2014;即添加在代码执行期间锁定合约的状态变量，防止重入调用。

应用所有这些技术（不需要全部使用三种，但是我们这里是出于说明目的）到 _EtherStore.sol_，可以避免再入的合约：

[source,solidity,linenums]
----
  1 contract EtherStore {
  2 
  3     // initialize the mutex
  4     bool reEntrancyMutex = false;
  5     uint256 public withdrawalLimit = 1 ether;
  6     mapping(address => uint256) public lastWithdrawTime;
  7     mapping(address => uint256) public balances;
  8 
  9     function depositFunds() external payable {
 10         balances[msg.sender] += msg.value;
 11     }
 12 
 13     function withdrawFunds (uint256 _weiToWithdraw) public {
 14         require(!reEntrancyMutex);
 15         require(balances[msg.sender] >= _weiToWithdraw);
 16         // limit the withdrawal
 17         require(_weiToWithdraw <= withdrawalLimit);
 18         // limit the time allowed to withdraw
 19         require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
 20         balances[msg.sender] -= _weiToWithdraw;
 21         lastWithdrawTime[msg.sender] = now;
 22         // set the reEntrancy mutex before the external call
 23         reEntrancyMutex = true;
 24         msg.sender.transfer(_weiToWithdraw);
 25         // release the mutex after the external call
 26         reEntrancyMutex = false;
 27     }
 28  }
----

[[real_world_example_the_dao]]
==== 真实案例：DAO

((("DAO (Decentralized Autonomous Organization)","reentrancy attack")))((("reentrancy attacks","real-world example: DAO attack")))DAO（去中心化自治组织）攻击是一个发生在以太坊的早期发展时期的主要骇客攻击事件。当时，合约中持有超过1.5亿美元。重入播放在攻击中起到了主要作用，最终导致以太坊的硬分叉从而产生了以太坊经典（ETC）。有关DAO漏洞的仔细分析，请参见 http://bit.ly/2EQaLCI 。有关以太坊分叉历史，DAO hack时间轴以及ETC在硬分叉中诞生的更多信息，请参见<<ethereum_standards>>.(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc4")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc3")))

=== 数学运算中的上限/下限溢出

((("arithmetic over/underflows", id="ix_09smart-contracts-security-asciidoc6", range="startofrange")))((("overflow", id="ix_09smart-contracts-security-asciidoc7", range="startofrange")))((("security (smart contracts)","arithmetic over/underflow threat", id="ix_09smart-contracts-security-asciidoc8", range="startofrange")))((("underflow", id="ix_09smart-contracts-security-asciidoc9", range="startofrange")))以太坊虚拟机为整数指定固定大小的数据类型这意味着整数变量只能代表一定范围内的数字。例如， `uint8` 只能存储[0,255]范围内的数字。如果试图将 `256` 存储到 `uint8` 中得到的结果为 `0`。如果不注意，Solidity中的变量可以变成漏洞，比如当用户输入没有检查而执行计算，而导致结果数字超出数据类型的存储范围。

有关算术上限溢出/下限溢出的更多信息，请参见如何保护智能合约 https://bit.ly/2nNLuOr[&#x201c;How to Secure Your Smart Contracts&#x201d;]，以太坊智能合约最佳实用指南 https://bit.ly/2MOfBPv[Ethereum Smart Contract Best Practices], 和 https://bit.ly/2xvbx1M[&#x201c;Ethereum, Solidity and integer overflows: programming blockchains like 1970&#x201d;].

[role="notoc"]
==== 漏洞

((("arithmetic over/underflows","vulnerability", id="ix_09smart-contracts-security-asciidoc10", range="startofrange")))上限溢出/下限溢出错误在执行以下操作时发生，一个固定大小的变量存储的数字（或数据）超出了变量的数据类型范围。

((("underflow")))例如，从值为0的uint8（8位无符号整数；即非负数）变量中减去1。会导致结果为255。这是一个下限溢出错误 _underflow_。我们定义了一个数字低于 `uint8` 的范围，因此结果导致了回转并给出了uint8可以存储的最大数量。类似地，将 `2^8^ = 256` 添加到 `uint8` 类型的变量将使变量值保持不变，因为我们已经转回uint的整个长度。两个简单类比的情况是汽车中用于测量行进距离的里程表（里程表达到最大值后会重置为000000，即最大数超过999999）和数学中的周期函数（在 +sin+ 的参数上加上 +2π+ 会使值保持不变）。

((("overflow","defined")))添加大于数据类型范围的数字称为溢出 _overflow_。比如，将 `257` 添加到当前值为 `0` 的 `uint8` 中，结果是数字 `1`。固定大小的变量可以被视为是循环的，如果在最大的变量值上方加上数字，我们将回到零，如果从零做递减，则回到最大数字。对于带符号的 `int` 类型，即可以有负数的整型变量，一旦达到最大的负值，我们将再次开始；例如，如果我们尝试从值为 `-128` 的 `int8` 中减去 `1`，则会得到 `127`。

这些数字陷阱可以被攻击者滥用代码并创建意外的逻辑流程。例如，请考虑以下内容中的 +TimeLock+ 合约：
<<timelock_sol_security>>.

[[timelock_sol_security]]
.TimeLock.sol
====
[source,solidity,linenums]
----
  1 contract TimeLock {
  2 
  3     mapping(address => uint) public balances;
  4     mapping(address => uint) public lockTime;
  5 
  6     function deposit() external payable {
  7         balances[msg.sender] += msg.value;
  8         lockTime[msg.sender] = now + 1 weeks;
  9     }
 10 
 11     function increaseLockTime(uint _secondsToIncrease) public {
 12         lockTime[msg.sender] += _secondsToIncrease;
 13     }
 14 
 15     function withdraw() public {
 16         require(balances[msg.sender] > 0);
 17         require(now > lockTime[msg.sender]);
 18         balances[msg.sender] = 0;
 19         msg.sender.transfer(balance);
 20     }
 21 }
----
====

该合约设计为一个时间保险库：用户可以将以太币存入合约，它将至少被锁定在合约中一周。用户可以选择将等待时间延长至1周以上，但是一旦存入，用户可以确保其以太币被安全锁定至少持续一周&#x2014;或按合约中的约定时间。

如果用户被迫交出其私钥，则诸如这样的合约可能会便于确保在短时间内无法获得合约的以太币。但是如果用户在该合约中锁定了 `100以太币`，并将其密钥移交给了攻击者，那么攻击者可以使用溢出方式来盗取以太币，而跳过 `锁定时间` 的限制。

攻击者可以指定当前的 `lockTime` 到他们的地址，即所掌握的公钥（这是一个公共变量）。我们称之为 `userLockTime`。然后，他们可以调用 `increaseLockTime` 函数，然后将数字 2^256^ - userLockTime 作为参数传递。这个数字会被加到到当前 `userLockTime` 值并导致溢出，重置lockTime [msg.sender]的值为0。然后，攻击者可以简单地调用 `withdraw` 函数获得他们的奖励。

让我们看另一个例子（<<underflow_vulnerability_example_from_ethernaut_challenge>>），该内容来自 https://github.com/OpenZeppelin/ethernaut[Ethernaut challenges]。

*SPOILER ALERT：* _如果你尚未完成Ethernaut挑战，这里提供一个解决方案之一_。

[[underflow_vulnerability_example_from_ethernaut_challenge]]
.Ethernaut挑战的underflow漏洞示例
====
[source,solidity,linenums]
----
  1 pragma solidity ^0.4.18;
  2 
  3 contract Token {
  4 
  5   mapping(address => uint) balances;
  6   uint public totalSupply;
  7 
  8   function Token(uint _initialSupply) {
  9     balances[msg.sender] = totalSupply = _initialSupply;
 10   }
 11 
 12   function transfer(address _to, uint _value) public returns (bool) {
 13     require(balances[msg.sender] - _value >= 0);
 14     balances[msg.sender] -= _value;
 15     balances[_to] += _value;
 16     return true;
 17   }
 18 
 19   function balanceOf(address _owner) public constant returns (uint balance) {
 20     return balances[_owner];
 21   }
 22 }
----
====

这是一个简单的通证合约，包含了 `transfer` 函数，允许拥有者转移通证。你看到这个合约里面的错误了吗？

问题来自 `transfer` 函数。在第13行的 +require+ 语句可能产生下限溢出。考虑一个用户只有零的余额。他们可以用调用 `transfer` 函数使用非零的参数 `value` 并在第13行通过 +require+ 语句。这是因为 `balances[msg.sender]` 是 +0+ （变量类型为 `uint256`），因此减去正值（不包括 2^256^ ）将产生一个正数，如前所述。第14行也是如此余额将记入正数。因此，在这个例子中，由于下限溢出漏洞，攻击者可以获得免费通证。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc10")))

[role="notoc"]
==== 预防技术

((("arithmetic over/underflows","preventative techniques", id="ix_09smart-contracts-security-asciidoc11", range="startofrange")))当前用于防止下限/上限溢出错误的常规技术是使用或建立数学库来替代标准数学运算的加法，减法和乘法（除法不会导致上限/下限溢出，EVM的操作会在除数为0时回退）。

((("OpenZeppelin")))((("SafeMath library")))https://github.com/OpenZeppelin/openzeppelin-solidity[OpenZeppelin] 项目在为以太坊社区构建和审核安全库方面做得非常出色。特别是，它的 +SafeMath+ 库 http://bit.ly/2ABhb4l[+SafeMath+ library] 可用于避免溢出漏洞。

为了演示如何在Solidity中使用这些库，让我们使用SafeMath库更正TimeLock合约。合约的无溢出版本为：

[source,solidity,linenums]
----
  1 library SafeMath {
  2 
  3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
  4     if (a == 0) {
  5       return 0;
  6     }
  7     uint256 c = a * b;
  8     assert(c / a == b);
  9     return c;
 10   }
 11 
 12   function div(uint256 a, uint256 b) internal pure returns (uint256) {
 13     // assert(b > 0); // Solidity automatically throws when dividing by 0
 14     uint256 c = a / b;
 15     // assert(a == b * c + a % b); // This holds in all cases
 16     return c;
 17   }
 18 
 19   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
 20     assert(b <= a);
 21     return a - b;
 22   }
 23 
 24   function add(uint256 a, uint256 b) internal pure returns (uint256) {
 25     uint256 c = a + b;
 26     assert(c >= a);
 27     return c;
 28   }
 29 }
 30 
 31 contract TimeLock {
 32     using SafeMath for uint; // use the library for uint type
 33     mapping(address => uint256) public balances;
 34     mapping(address => uint256) public lockTime;
 35 
 36     function deposit() external payable {
 37         balances[msg.sender] = balances[msg.sender].add(msg.value);
 38         lockTime[msg.sender] = now.add(1 weeks);
 39     }
 40 
 41     function increaseLockTime(uint256 _secondsToIncrease) public {
 42         lockTime[msg.sender] = lockTime[msg.sender].add(_secondsToIncrease);
 43     }
 44 
 45     function withdraw() public {
 46         require(balances[msg.sender] > 0);
 47         require(now > lockTime[msg.sender]);
 48         balances[msg.sender] = 0;
 49         msg.sender.transfer(balance);
 50     }
 51 }
----

请注意，所有标准数学运算已被替换为那些在 `SafeMath` 库中定义的运算。 `TimeLock` 合约不再执行任何可能导致溢出的操作。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc11")))

==== 真实案例：PoWHC和批量传输溢出（CVE-2018–10299）

((("arithmetic over/underflows","real-world examples: PoWHC and batch transfer overflow")))((("batchTransfer function")))((("Proof of Weak Hands Coin (PoWHC)")))最初被设计为开玩笑的弱手币（PoWHC）是由一群互联网用户编写的庞氏骗局。不幸的是，合约的编写者似乎之前从未见过溢出问题，因此有866个以太币被从合约中盗走。 Eric Banisadr在他的博客中很好地概述了下限溢出是如何发生的（与之前描述的Ethernaut挑战不一样） https://bit.ly/2wrxIFJ[blog post]。

http://bit.ly/2CUf7WG[另一个示例]来自将 `batchTransfer()` 函数实现到一组ERC20通证合约中。该实现包含一个溢出漏洞；你可以在 https://bit.ly/2HDlIs8[PeckShield's account] 中了解详细信息。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc9")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc8")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc7")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc6")))

=== 意外的以太币

((("ether (generally)","unexpected ether security threat", id="ix_09smart-contracts-security-asciidoc12", range="startofrange")))((("security (smart contracts)","unexpected ether threat", id="ix_09smart-contracts-security-asciidoc13", range="startofrange")))((("unexpected ether","security threat from", id="ix_09smart-contracts-security-asciidoc14", range="startofrange")))
通常，将以太币发送至合约时，必须执行fallback函数或合约中定义的其他函数。这里面有两个例外，即以太币可以存在于合约中，但没有执行任何代码。依赖代码执行的合约发送给它们的所有以太币都可能容易受到攻击，导致其中的以太币会强行发送到攻击地址。

有关此内容的更多信息，请参见 https://bit.ly/2MR8Gp0[&#x201c;如何保护您的智能合约&#x201d;]  和 http://bit.ly/2RjXmUWl[&#x201c;Solidity安全模式 - 强制以太入合约&#x201d;]。

[role="notoc"]
==== 漏洞

((("unexpected ether","vulnerability", id="ix_09smart-contracts-security-asciidoc15", range="startofrange")))一个((("invariant checking")))常见的防御性编程技术，可以被用来确保正确的状态转换或验证操作，称为 _不变性检查_。此技术涉及定义一组非变量（不应更改的指标或参数）并检查在一次（或多次）操作后，它们的值保持不变。这通常是好的设计，即要检查非变量实际上的值不变。非变量的一个例子是用于固定发行量的 http://bit.ly/2CUf7WG[ERC20通证]的 `totalSupply`。由于没有函数可以修改此非变量，因此可以添加一个检查确保 `transfer` 函数的运行保证 `totalSupply` 的值保持不变，以确保函数按预期运行。

特别是，有一个明显的非变量可能看起来非常好用但这实际上可以由外部用户操纵（无论合约中所设置的规则如何实现）。这就是当前存储在合约中的以太币。当开发人员第一次学习Solidity时，他们通常会误认为合约如果要接受或获取以太币的话，必须通过payable函数。这种误解可能导致合约做出具有错误的假设，比如说合约的以太币余额，这可能导致一系列漏洞。此漏洞主要是对合约余额的（错误）用法，即变量 `this.balance`.

可以通过两种方式（强制）将以太币发送到合约中而无需使用payable函数或通过合约执行任何代码：

自毁/自杀:: 

((("selfdestruct function"))) 任何合约都可以实现 http://bit.ly/2RovrDf[ `自毁` 函数]，从合约地址中删除所有字节码并将所有存储的以太币发送到参数指定的地址。如果这个地址也是合约，其中没有函数（包括fallback函数）被调用。因此，`selfdestruct` 函数可以是用来强行将以太币发送给任何合约，无论合约中是否存在代码，甚至合约中没有payable函数。这意味着任何攻击者都可以产生一个带有 `selfdestruct` 函数的合约，向其发送以太币，调用 `selfdestruct（target）` 函数并强制将以太币发送至 `目标` 合约。马丁·斯文德（Martin Swende）在他的博客 http://bit.ly/2OfLukM[blog post] 中描述了自毁操作码的一些怪异（Quirk＃2）情况以及关于客户端节点如何检查错误的不正确的常量说明，这可能导致以太坊网络的灾难性崩溃。

预先发送以太币:: 

将以太币发送到合约的另一种方法是预加载含有以太币的合约地址。合约地址是确定性的&#x2014;实际上，该地址是根据Keccak-256（通常也称为SHA-3）的哈希算法对创建合约的地址和创建合约时的交易计数而得出的。具体来说，其格式为 `address = sha3(rlp.encode([account_address,transaction_nonce]))`（有关此功能的一些有趣用例，请参见Adrian Manning对 http://bit.ly/2EPj5Tq["Keyless Ether"]的讨论）。这意味着任何人都可以计算出合约的地址并在其创建之前发送以太币到该地址。当合约创建后它将具有非零的以太币余额。

让我们看看在掌握这些知识后可能会出现的一些陷阱。考虑一下<<etherGame_security>>中的简单合约。

[[etherGame_security]]
.EtherGame.sol
====
[source,solidity,linenums]
----
  1 contract EtherGame {
  2 
  3     uint public payoutMileStone1 = 3 ether;
  4     uint public mileStone1Reward = 2 ether;
  5     uint public payoutMileStone2 = 5 ether;
  6     uint public mileStone2Reward = 3 ether;
  7     uint public finalMileStone = 10 ether;
  8     uint public finalReward = 5 ether;
  9 
 10     mapping(address => uint) redeemableEther;
 11     // Users pay 0.5 ether. At specific milestones, credit their accounts.
 12     function play() external payable {
 13         require(msg.value == 0.5 ether); // each play is 0.5 ether
 14         uint currentBalance = this.balance + msg.value;
 15         // ensure no players after the game has finished
 16         require(currentBalance <= finalMileStone);
 17         // if at a milestone, credit the player's account
 18         if (currentBalance == payoutMileStone1) {
 19             redeemableEther[msg.sender] += mileStone1Reward;
 20         }
 21         else if (currentBalance == payoutMileStone2) {
 22             redeemableEther[msg.sender] += mileStone2Reward;
 23         }
 24         else if (currentBalance == finalMileStone ) {
 25             redeemableEther[msg.sender] += finalReward;
 26         }
 27         return;
 28     }
 29 
 30     function claimReward() public {
 31         //确保游戏完成
 32         require(this.balance == finalMileStone);
 33         //确保可以分发奖励
 34         require(redeemableEther[msg.sender] > 0);
 35         redeemableEther[msg.sender] = 0;
 36         msg.sender.transfer(transferValue);
 37     }
 38  }
----
====

该合约代表一个简单的游戏（自然会涉及比赛条件）玩家向合约发送0.5的以太币，希望成为达到以下三个里程碑里的第一名。里程碑以以太币结算。首先达到里程碑可以会在游戏结束后，获取一部分以太币。游戏当最后的里程碑（10个以太币）达到时结束；然后，玩家可以获取他们的奖励。

`EtherGame` 合约的问题来自对游戏的不当使用第14行（关联第16行）和第32行中的 `this.balance` 变量。一个捣蛋的攻击者可以通过 `selfdestruct` 函数（前面讨论过）将少量的以太币（例如0.1以太币）强行发送到合约而阻止任何未来的玩家达成里程碑。由于这0.1个以太币， `this.balance`永远不会是0.5的倍数因为所有合法玩家只能发送0.5个以太币增量。这样可以阻止第18、21行以及24行的所有 +if+ 条件为真。

更糟糕的是，一个错过里程碑的攻击者可能会强行发送10个以太币（或足量的以太币可以使得合约的余额高于 `finalMileStone`），这将会永远锁定所有合约中的奖励。这是因为 `claimReward` 函数将永远重置，原因是第32行上的 +require+ 条件无法满足（因为 `this.balance` 的值大于 `finalMileStone`）。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc15")))

[role="notoc"]
==== 预防技术

((("unexpected ether","preventative techniques")))这种漏洞通常是由于不恰当使用 `this.balance` 引起的。如果可能，合约中的逻辑应避免依赖于确切合约余额的价值，因为它可以人为地被操纵。如果基于 `this.balance` 应用逻辑，则必须考虑处理意外的余额。

如果需要精确的以太币余额值，则可以使用一个自定义变量，其值可以在payable函数中递增使用，以确保安全跟踪存入的以太币。此变量将不受通过 `selfdestruct` 调用强制发送到合约的以太币影响。

考虑到这一点，`EtherGame` 合约的更正版本可以像下面这样：

[source,solidity,linenums]
----
  1 contract EtherGame {
  2 
  3     uint public payoutMileStone1 = 3 ether;
  4     uint public mileStone1Reward = 2 ether;
  5     uint public payoutMileStone2 = 5 ether;
  6     uint public mileStone2Reward = 3 ether;
  7     uint public finalMileStone = 10 ether;
  8     uint public finalReward = 5 ether;
  9     uint public depositedWei;
 10 
 11     mapping (address => uint) redeemableEther;
 12 
 13     function play() external payable {
 14         require(msg.value == 0.5 ether);
 15         uint currentBalance = depositedWei + msg.value;
 16         // ensure no players after the game has finished
 17         require(currentBalance <= finalMileStone);
 18         if (currentBalance == payoutMileStone1) {
 19             redeemableEther[msg.sender] += mileStone1Reward;
 20         }
 21         else if (currentBalance == payoutMileStone2) {
 22             redeemableEther[msg.sender] += mileStone2Reward;
 23         }
 24         else if (currentBalance == finalMileStone ) {
 25             redeemableEther[msg.sender] += finalReward;
 26         }
 27         depositedWei += msg.value;
 28         return;
 29     }
 30 
 31     function claimReward() public {
 32         //确保游戏完成
 33         require(depositedWei == finalMileStone);
 34         //确保可以分发奖励
 35         require(redeemableEther[msg.sender] > 0);
 36         redeemableEther[msg.sender] = 0;
 37         msg.sender.transfer(transferValue);
 38     }
 39  }
----

在这里，我们创建了一个新变量 `depositedWei`，用以跟踪已知的以太币存款，这个变量就可以被用于我们的测试。请注意，我们不再有任何变量指向 `this.balance`。

==== 其他示例

下面的资料中给出了一些有问题合约的例子。 https://github.com/Arachnid/uscc/tree/master/submissions-2017/[Underhanded Solidity Coding Contest]，其中还提供了许多本节提出的陷阱的例子。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc14")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc13")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc12")))

=== DELEGATECALL

((("DELEGATECALL opcode security threat", id="ix_09smart-contracts-security-asciidoc16", range="startofrange")))((("security (smart contracts)","DELEGATECALL opcode threat", id="ix_09smart-contracts-security-asciidoc17", range="startofrange"))) `CALL` 和 `DELEGATECALL` 操作码对于以太坊开发者将其代码模块化非常有用。 ((("CALL opcode")))标准外部消息调用合约由 `CALL` 操作码处理，相应调用代码在外部合约/函数的范围内运行。除了在目标地址执行的代码是在调用合约的范围中运行而msg.sender和msg.value保持不变， `DELEGATECALL` 操作码与其几乎相同。这个特征启用 _libraries_ 的实现，从而使开发人员能够只需部署一次可重复使用的代码，并从将来的合约中调用它。

尽管这两个操作码之间的区别很简单和直观，但使用DELEGATECALL可能会导致意外代码的执行结果。

有关这方面的更多资料，请参阅Loi.Luu的 http://bit.ly/2AAElb8[Ethereum Stack Exchange question on this topic] 和 http://bit.ly/2Oi7UlH[Solidity 文档]。

[role="notoc"]
==== 漏洞

((("DELEGATECALL opcode security threat","vulnerability", id="ix_09smart-contracts-security-asciidoc18", range="startofrange")))由于 `DELEGATECALL` 具有范围内的保留特性，创建没有漏洞的自定义库并不像人们想象的那么容易。库中的代码本身可以是安全的并且没有漏洞。但是，在另一个应用程序的范围中运行时，新的漏洞可能会出现。 ((("Fibonacci sequences", id="ix_09smart-contracts-security-asciidoc19", range="startofrange"))) 让我们来看一个相当复杂的例子，比如使用斐波那契数列。

考虑<<fibonacci_security>>中的软件库，可以生成斐波那契数列和类似形式的序列。（注意：此代码为从 https://bit.ly/2MReuii[] 修改而来。）

[[fibonacci_security]]
.FibonacciLib.sol
====
[source,solidity,linenums]
----
// library contract - calculates Fibonacci-like numbers
contract FibonacciLib {
    // initializing the standard Fibonacci sequence
    uint public start;
    uint public calculatedFibNumber;

    // modify the zeroth number in the sequence
    function setStart(uint _start) public {
        start = _start;
    }

    function setFibonacci(uint n) public {
        calculatedFibNumber = fibonacci(n);
    }

    function fibonacci(uint n) internal returns (uint) {
        if (n == 0) return start;
        else if (n == 1) return start + 1;
        else return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
----
====

该库合约提供了可以生成第 _n_ 个斐波纳契序列中的数字的函数。它允许用户更改序列的起始值（`start`）并在这个新的序列中计算第 _n_ 个类斐波那契数字。

现在让我们考虑一个利用该库的合约，如<<fib_balance_security>>。

[[fib_balance_security]]
.FibonacciBalance.sol
====
[source,solidity,linenums]
----
  1 contract FibonacciBalance {
  2 
  3     address public fibonacciLibrary;
  4     // the current Fibonacci number to withdraw
  5     uint public calculatedFibNumber;
  6     // the starting Fibonacci sequence number
  7     uint public start = 3;
  8     uint public withdrawalCounter;
  9     // the Fibonancci function selector
 10     bytes4 constant fibSig = bytes4(sha3("setFibonacci(uint256)"));
 11 
 12     // constructor - loads the contract with ether
 13     constructor(address _fibonacciLibrary) external payable {
 14         fibonacciLibrary = _fibonacciLibrary;
 15     }
 16 
 17     function withdraw() {
 18         withdrawalCounter += 1;
 19         // calculate the Fibonacci number for the current withdrawal user-
 20         // this sets calculatedFibNumber
 21         require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));
 22         msg.sender.transfer(calculatedFibNumber * 1 ether);
 23     }
 24 
 25     // allow users to call Fibonacci library functions
 26     function() public {
 27         require(fibonacciLibrary.delegatecall(msg.data));
 28     }
 29 }
----
====

该合约允许参与者从合约中提取以太币，条件是以太币的数量等于一个斐波那契数并对应于参与者的提款顺序；即，第一个参与者得到1个以太币，第二个也得到1，第三个得到2，第四得到3，第五得到5，依此类推（直到合约余额小于要提取的斐波那契数）。

// TODO: Andreas to decide if this intro is necessary, or to simply refer to
// another section of the book.

该合约中有许多要素可能需要更多的说明。首先，有一个有趣的变量 `fibSig`。它持有字符串 `'setFibonacci(uint256)'` 的Keccak-256(SHA-3)散列的前4个字节，这就是所谓的 http://bit.ly/2RmueMP[函数选择器]，它被放入 `calldata` 中以指定智能合约中哪个函数将被调用。它在第21行 `delegatecall` 函数中使用，指定我们希望运行 `fibonacci(uint256)` 函数。 `delegatecall` 中的第二个参数是我们传递到函数里面的参数。其次，我们假设在构造函数中正确引用了FibonacciLib库（<<external_contract_referencing>>中讨论一些与此类合约参考初始化有关的潜在漏洞）。

你能发现合约中有任何错误吗？如果要部署此合约，用以太币填充它，并调用 `withdraw`，它可能会还原。

你可能已经注意到，状态变量 `start` 同时存在于库合约和主调合约中。在库合约中，`start` 用于指定斐波纳契数列的开始并将其设置为 `0`，而在调用合约中则设置为 `3`。你可能还注意到， `FibonacciBalance` 合约中的fallback函数允许将所有调用传递到库合约，允许库合约setStart函数被调用。考虑到我们保留了合约的状态，此函数将允许你更改本地 `FibonnacciBalance` 合约中 `start` 变量的状态。如果是这样，这将允许用户提取更多的以太币，因为 `calculatedFibNumber` 取决于 `start` 变量（如库合约中所见）。实际上，`setStart` 函数没有（也不能）修改 `FibonacciBalance` 合约中的 `start` 变量该合约的潜在漏洞远远比修改 `start` 变量更糟糕。

// TODO: Andreas to decide if this intro is necessary, or to simply refer to
// another section of the book.

在讨论实际问题之前，让我们快速回顾一下状态变量实际上是如何存储在合约中的。状态或存储变量（变量值在单个交易中不变）是按合约中的它们出现的顺序放入 _slots_ 中的。（这里有些复杂；请参阅 http://bit.ly/2JslDWf[Solidity docs] 以获取更全面的了解。）

作为示例，让我们看一下库合约。它有两个状态变量，`start` 和 `calculatedFibNumber`。第一个变量 `start` 存储在合约的存储区中的 `slot[0]` 处（即第一个slot）。第二个变量 `calculatedFibNumber` 是放置在下一个可用的存储位置 `slot[1]` 中。函数 `setStart` 接受输入并将 `start` 设置为任何输入值。因此，该函数将 `slot[0]` 设置为任何我们在 `setStart` 函数中提供的输入值。同样，`setFibonacci` 函数将 `calculatedFibNumber` 设置为 `fibonacci(n)` 的结果。同样，这只是将存储空间 `slot[1]` 设置为 `fibonacci(n)` 的值。

现在让我们看一下 `FibonacciBalance` 合约。存储 `slot[0]` 现在对应于 `fibonacciLibrary` 地址，而 `slot[1]` 对应于 `calculatedFibNumber`。正是在这种不正确的映射中发生了漏洞。 `delegatecall` _保留合约上下文_。这意味着通过 `delegatecall` 执行该代码将作用于调用合约的状态（即存储）。

现在注意在 `withdraw` 中的第21行，我们执行 `fibonacciLibrary.delegatecall(fibSig，withdrawalCounter)`。这个调用setFibonacci函数，正如我们所讨论的，它修改了存储 `slot[1]`，在我们当前的范围中是 `calculatedFibNumber`。这个是符合预期（即执行后， `calculatedFibNumber` 被修改了）。但是，请注意 `start` 变量在 `FibonacciLib` 合约中的存储是位于 `slot[0]` 中，即当前合约中的 `fibonacciLibrary` 地址。这意味着 `fibonacci` 函数会产生意外结果。这是因为它引用的位置是 `start`（`slot[0]`），在当前调用范围中是 `fibonacciLibrary` 地址（通常，当按照 `uint` 类似存储时会很大）。因此，很可能 `withdraw` 函数将回退，因为它将不包含 `uint(fibonacciLibrary)` 以太币的数量，即 `calculatedFibNumber` 将返回的值。

更糟糕的是，`FibonacciBalance` 合约允许用户调用所有 `fibonacciLibrary` 中的函数，这个是通过第26行的fallback函数来实现的。正如我们前面所讨论的，这包括 `setStart` 函数。我们讨论该函数允许任何人修改或设置在 `slot[0]` 中的内容。在这种情况下，存储 `slot[0]` 是 `fibonacciLibrary` 地址。因此，攻击者可能会创建恶意合约，将地址转换为 `uint` （可以是使用在Python中轻松完成 `int('<address>'，16)`），然后调用 `setStart(<attack_contract_address_as_uint>)` 函数。这将把 `fibonacciLibrary` 的地址改到攻击合约的地址。然后，每当一个用户调用 `withdraw` 或fallback函数，恶意合约将执行（可以窃取合约的全部余额）因为我们已经修改了fibonacciLibrary的实际地址。一个此类攻击合约的示例为：

[source,solidity,linenums]
----
contract Attack {
    uint storageSlot0; // corresponds to fibonacciLibrary
    uint storageSlot1; // corresponds to calculatedFibNumber

    // fallback - this will run if a specified function is not found
    function() public {
        storageSlot1 = 0; // we set calculatedFibNumber to 0, so if withdraw
        // is called we don't send out any ether
        <attacker_address>.transfer(this.balance); // we take all the ether
    }
 }
----

注意，该攻击合约通过以下方式修改了 `calculatedFibNumber`：更改存储空间 `slot[1]`。原则上，攻击者可以修改任何他们选择的其他存储插槽，以对此合约进行各种攻击。我们建议你将这些合约放入 https://remix.ethereum.org[Remix] ，并通过这些 `delegatecall` 函数尝试不同的攻击合约和状态更改。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc19")))

同样重要的是要注意，当我们说 `delegatecall` 是保持状态，我们不是在谈论合约中变量的名称，而是这些名称指向的实际存储插槽。如你可以从此示例中看到，一个简单的错误可能导致攻击者劫持整个合约及其以太币。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc18")))

[role="notoc"]
==== 预防技术

((("DELEGATECALL opcode security threat","preventative techniques"))) Solidity提供 `library` 关键字用于实现库合约（有关更多详细信息，请参见 http://bit.ly/2zjD8TI[docs]）。这样可以确保库合约是无状态且无自毁函数。将库合约强制设为无状态降低了本节所展示的存储环境的复杂性问题。无状态库还可以防止攻击者直接修改库合约的状态以影响其它依赖库合约代码的合约。根据一般经验，当使用 `DELEGATECALL` 时要特别注意可能的调用范围，包括库合约和调用合约，以及尽可能建立无状态 pass:[<span class="keep-together">库</span>]。

[[multisig_secondhack]]
==== 真实案例：Pairty Multisig钱包（Second Hack）

((("DELEGATECALL opcode security threat","real-world example: Parity Multisig Wallet hack", id="ix_09smart-contracts-security-asciidoc20", range="startofrange")))((("Parity Multisig Wallet","second hack", id="ix_09smart-contracts-security-asciidoc21", range="startofrange")))((("wallets","Parity Multisig Wallet hacks", id="ix_09smart-contracts-security-asciidoc22", range="startofrange")))第二个Parity Multisig Wallet黑客程序是一个用于说明运行编写良好的库代码如果运行在预期的范围之外会导致问题的例子。有很多关于这次黑客攻击的很好的解释，例如 http://bit.ly/2Dg7GtW[&#x201c;Parity Multisig Hacked. Again&#x201d;] 和 http://bit.ly/2Of06B9[&#x201c;An In-Depth Look at the Parity Multisig Bug&#x201d;].

为了增加理解这些资料，让我们了解一下出现问题的合约。相应的库文件合钱包合约可以在 http://bit.ly/2OgnXQC[on GitHub]上找到。

库合约如下：

[source,solidity,linenums]
----
contract WalletLibrary is WalletEvents {

  ...

  // throw unless the contract is not yet initialized.
  modifier only_uninitialized { if (m_numOwners > 0) throw; _; }

  // constructor - just pass on the owner array to multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit)
      only_uninitialized {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }

  // kills the contract sending everything to `_to`.
  function kill(address _to) onlymanyowners(sha3(msg.data)) external {
    suicide(_to);
  }

  ...

}
----

下面是钱包合约：

[source,solidity,linenums]
----
contract Wallet is WalletEvents {

  ...

  // METHODS

  // gets called when no other function matches
  function() payable {
    // just being sent some cash?
    if (msg.value > 0)
      Deposit(msg.sender, msg.value);
    else if (msg.data.length > 0)
      _walletLibrary.delegatecall(msg.data);
  }

  ...

  // FIELDS
  address constant _walletLibrary =
    0xcafecafecafecafecafecafecafecafecafecafe;
}
----

请注意，`Wallet` 合约实质上使用委托调用将所有调用传递给WaltLibrary合约。常数 `_walletLibrary` 的合约地址用作以下内容的占位符：实际部署的 `WalletLibrary` 合约（位于 `0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4`).

这些合约的预期操作是产生一个简单的低成本可部署的 `Wallet` 合约，其代码库和主要功能在 `WalletLibrary` 合约中。问题是， `WalletLibrary` 合约本身就是合约而且保持自己的状态。你知道为什么这可能是个问题？

用户可以通过 pass:[ <code><span class="keep-together">WalletLibrary</span></code> ]调用合约本身。具体来说， pass:[ <code><span class="keep-together">WalletLibrary</span></code> ]合约可以被初始化，并被拥有。实际上，一个用户这样做了，他调用了 `initWallet` 函数并成为了 `WalletLibrary` 库合约的所有者。同一用户随后调用了 `kill` 函数。因为用户是库合约的所有者，修改通过，然后库合约自毁了。所有现有的 `Wallet` 合约，如果是使用了这个库合约，并且没有包含可以更改此引用的方法，那么它们所有的功能，包括提取以太坊的能力，就会与 `WalletLibrary` 合约一起丢失。结果，所有的存在此类Parity multisig钱包中的以太币，它们立即丢失或永久不可恢复(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc22")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc21")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc20"))).(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc17")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc16")))

=== 默认的可见性

((("default visibility specifier security problem", id="ix_09smart-contracts-security-asciidoc23", range="startofrange")))((("security (smart contracts)","default visibility specifier threat", id="ix_09smart-contracts-security-asciidoc24", range="startofrange")))((("Solidity","default visibility specifier problem", id="ix_09smart-contracts-security-asciidoc25", range="startofrange")))((("visibility specifiers", id="ix_09smart-contracts-security-asciidoc26", range="startofrange")))Solidity中的函数具有可见性说明符，这些说明符指示了这些函数可以被调用。可见性是用以确定一个函数可以由用户，其他衍生合约在外部调用，仅在内部调用，或仅在外部调用。总共有四个可见性说明符，在 http://bit.ly/2ABiv7j[Solidity docs]中有详细说明。函数默认为 `public`，即允许用户从外部调用它们现在，我们将看到对可见性说明符的错误使用将如何导致智能合约中的一些破坏性漏洞。

[role="notoc"]
==== 漏洞

((("default visibility specifier security problem","vulnerability")))函数的默认可见性是 `public`，因此函数如果未指定其可见性，则默认可以被外部用户调用。问题出现在当开发人员错误地忽略可见性说明符时，比如没有设置应该是私有的（或只能在合约内部调用）函数。

让我们快速浏览一个简单的示例：

[source,solidity,linenums]
----
contract HashForEther {

    function withdrawWinnings() {
        // Winner if the last 8 hex characters of the address are 0
        require(uint32(msg.sender) == 0);
        _sendWinnings();
     }

     function _sendWinnings() {
         msg.sender.transfer(this.balance);
     }
}
----

这个简单的合约旨在完成一个猜测地址的赏金游戏。为了赢得合约的余额，用户必须生成一个以太坊地址，其后8个十六进制字符为 +0+ 。一旦实现，他们可以调用 `withdrawWinnings` 函数来获取赏金。

不幸的是，其中未指定获取赏金函数的可见性。特别是，_sendWinnings函数是public（默认值），因此任何地址可以调用此函数以窃取赏金。

[role="notoc"]
==== 预防技术

((("default visibility specifier security problem","preventative techniques")))始终指定合约中所有函数的可见性是一个好习惯，即使它们都是有意 `公开` 的。最新版本的 +solc+ 会警告没有明确的可见性设置的函数，以鼓励这种做法。

==== 真实案例：Parity Multisig钱包（首次入侵）

((("default visibility specifier security problem","real world example: Parity Multisig Wallet hack")))((("Parity Multisig Wallet","first hack")))((("wallets","Parity Multisig Wallet hacks"))) 在第一个Parity multisig钱包黑客事件中，价值约3100万美元的以太币被盗，大部分来自于三个钱包。下面的这篇文章很好地回顾了这次攻击的情况 https://bit.ly/2vHiuJQ[Haseeb Qureshi].

本质上，multisig钱包由基本的 `Wallet` 合约构建而来，该合约调用一个包含核心功能的库合约（如<<multisig_secondhack>>中所示）。库合约包含初始化钱包的代码，可以从以下代码片段中看到：

[source,solidity,linenums]
----
contract WalletLibrary is WalletEvents {

  ...

  // METHODS

  ...

  // constructor is given number of sigs required to do protected
  // "onlymanyowners" transactionsas well as the selection of addresses
  // capable of confirming them
  function initMultiowned(address[] _owners, uint _required) {
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint(msg.sender);
    m_ownerIndex[uint(msg.sender)] = 1;
    for (uint i = 0; i < _owners.length; ++i)
    {
      m_owners[2 + i] = uint(_owners[i]);
      m_ownerIndex[uint(_owners[i])] = 2 + i;
    }
    m_required = _required;
  }

  ...

  // constructor - just pass on the owner array to multiowned and
  // the limit to daylimit
  function initWallet(address[] _owners, uint _required, uint _daylimit) {
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required);
  }
}
----

请注意，两个函数均未指定其可见性，因此都默认为 `public`。 `initWallet` 函数在钱包的构造函数中调用，并为在 `initMultiowned` 函数中为多重签名钱包设定所有者。由于这些功能被意外地保留为 `公开` 状态，因此攻击者能够根据已部署的合约调用这些功能，从而重置所有权为攻击者地址。作为所有者，攻击者就可以随后耗尽所有钱包中的以太币。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc26")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc25")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc24")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc23")))

[[entropyillusion_security]]
=== 熵幻像

((("entropy illusion security threat")))((("security (smart contracts)","entropy illusion threat")))以太坊区块链上的所有交易都是确定性状态过渡操作。这意味着每笔交易都会修改以太坊生态系统的全局状态，修改的结果是可以通过计算得到的，没有不确定性。这具意味着以太坊没有熵或随机性的来源。获取分布式的熵（随机性）是一个众所周知的问题，目前已经提出了许多解决方案，包括 https://github.com/randao/randao[RANDAO] 或使用哈希链，例如由Vitalik Buterin在博客文章中描述 https://vitalik.ca/files/randomness.html[&#x201c;Validator Ordering and Randomness in PoS&#x201d;].

[role="notoc"]
==== 漏洞

((("entropy illusion security threat","vulnerability"))) 以太坊平台上最先建立的一些合约是基于赌博游戏。从根本上讲，赌博需要不确定性（某些可以打赌的东西），这使得在区块链上构建赌博系统（确定性系统）相当困难。显然，不确定性必须来自区块链外部的来源。这对于玩家之间的下注（例如，参见 http://bit.ly/2CUh2KS[提交-披露技术]）是可能实现的；不过难度将大大提高，如果你想要编写一个合约可以充当“house”（例如二十一点或轮盘赌）的游戏。一个常见的陷阱是使用将来的区块变量-即，变量包含有关尚不知道其值的交易区块的信息，例如哈希值，时间戳记，区块编号或燃料限制。这些信息的问题是它们是由开采该区块的矿工控制的，因此不是真正随机的。考虑例如轮盘赌智能合约中的逻辑为，如果下一个区块哈希以偶数数字结尾则返回一个黑色数字。一名矿工（或矿工池）可能会下注100万美元。如果他们挖出来下一个区块并发现是以奇数结尾的哈希，他们可以选择不发布他们的区块而继续挖掘，除非他们找到一个区块哈希为偶数的解决方案（假设区块奖励和费用少于100万美元）。使用过去或现在的变量可能会导致更具破坏性的问题，就像马丁·斯文德（Martin Swende）在其博客 http://martin.swende.se/blog/Breaking_the_house.html[blog post]中所展示的那样。此外，如果仅使用区块变量意味着伪随机数在一个区块中所有的交易中将相同，因此攻击者可以通过在一个区块内完成许多交易来增加胜利的次数（如果有最大下注）。

[role="notoc"]
==== 预防技术

((("entropy illusion security threat","preventative techniques"))) 熵的源（随机性）必须在区块链外部。这可以在类似以下系统的参与方之间完成： http://bit.ly/2CUh2KS[commit–reveal],或通过将信任模型更改为一组参与者（如 https://github.com/randao/randao[RandDAO]）。也可以通过中心化实体用作随机性预言机。区块变量（一般来说，有一些例外）不应用作熵的来源，因为矿工可以操纵它们。

==== 真实案例：PRNG合约

((("entropy illusion security threat","real world example: PRNG contracts")))((("PRNG (pseudorandom number generator) contracts")))((("pseudorandom number generator (PRNG) contracts")))2018年2月，阿森尼·罗伊托夫（Arseny Reutov）在他的博客 http://bit.ly/2Q589lx[blogged] 中发表了对3,649个实时智能合约的分析，这些智能合约都使用了伪随机数生成器（PRNG）；他找到了43份合约可以被攻击。

[[external_contract_referencing]]
=== 外部合约引用

((("external contract referencing security threat", id="ix_09smart-contracts-security-asciidoc27", range="startofrange")))((("security (smart contracts)","external contract referencing threat", id="ix_09smart-contracts-security-asciidoc28", range="startofrange")))以太坊“世界计算机”的好处之一是能够重用代码并操作网络上已部署的合约。这个结果就是，大量合约引用了外部合约，通常通过外部消息调用。这些外部消息调用可以掩盖恶意行为者的意图，我们现在将对这些不明显的方式进行研究。

[role="notoc"]
==== 漏洞

((("external contract referencing security threat","vulnerability", id="ix_09smart-contracts-security-asciidoc29", range="startofrange")))在Solidity中，任何一个地址都可以代表一个合约，而不会考虑地址上的代码是否能代表正在投放的合约类型。这种情况可能会导致问题，尤其是在合约的作者尝试隐藏恶意代码。让我们用一个例子来说明。

考虑一段类似<<rot13_security>>中的代码，这基本实现了 https://en.wikipedia.org/wiki/ROT13[ROT13 cipher].

[[rot13_security]]
.Rot13Encryption.sol
====
[source,solidity,linenums]
----
// encryption contract
contract Rot13Encryption {

   event Result(string convertedString);

    // rot13-encrypt a string
    function rot13Encrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            // inline assembly to modify the string
            assembly {
                // get the first byte
                char := byte(0,char)
                // if the character is in [n,z], i.e. wrapping
                if and(gt(char,0x6D), lt(char,0x7B))
                // subtract from the ASCII number 'a',
                // the difference between character <char> and 'z'
                { char:= sub(0x60, sub(0x7A,char)) }
                if iszero(eq(char, 0x20)) // ignore spaces
                // add 13 to char
                {mstore8(add(add(text,0x20), mul(i,1)), add(char,13))}
            }
        }
        emit Result(text);
    }

    // rot13-decrypt a string
    function rot13Decrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            assembly {
                char := byte(0,char)
                if and(gt(char,0x60), lt(char,0x6E))
                { char:= add(0x7B, sub(char,0x61)) }
                if iszero(eq(char, 0x20))
                {mstore8(add(add(text,0x20), mul(i,1)), sub(char,13))}
            }
        }
        emit Result(text);
    }
}
----
====

此代码只是获取一个字符串（字母 ++a++&#x2013;++z++ ，无需验证），然后通过将每个字符向右移动13个位置来进行加密（在 `z` 之后回转）;即，`a` 移至 `n`，而 `x` 移至 `k`。如果不理解这个基于先前合约的汇编过程也没关系，不影响要讨论的问题正在讨论中，因此不熟悉汇编的读者可以简单地忽略它。

现在考虑以下合约，该合约使用此代码进行加密：

[source,solidity,linenums]
----
import "Rot13Encryption.sol";

// encrypt your top-secret info
contract EncryptionContract {
    // library for encryption
    Rot13Encryption encryptionLibrary;

    // constructor - initialize the library
    constructor(Rot13Encryption _encryptionLibrary) {
        encryptionLibrary = _encryptionLibrary;
    }

    function encryptPrivateData(string privateInfo) {
        // potentially do some operations here
        encryptionLibrary.rot13Encrypt(privateInfo);
     }
 }
----

该合约的问题在于，`encryptionLibrary` 地址并不是公开或固定的。因此，合约的部署者可以在构造函数中提供指向该合约的地址：

[source,solidity,linenums]
----
// encryption contract
contract Rot26Encryption {

   event Result(string convertedString);

    // rot13-encrypt a string
    function rot13Encrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            // inline assembly to modify the string
            assembly {
                // get the first byte
                char := byte(0,char)
                // if the character is in [n,z], i.e. wrapping
                if and(gt(char,0x6D), lt(char,0x7B))
                // subtract from the ASCII number 'a',
                // the difference between character <char> and 'z'
                { char:= sub(0x60, sub(0x7A,char)) }
                // ignore spaces
                if iszero(eq(char, 0x20))
                // add 26 to char!
                {mstore8(add(add(text,0x20), mul(i,1)), add(char,26))}
            }
        }
        emit Result(text);
    }

    // rot13-decrypt a string
    function rot13Decrypt (string text) public {
        uint256 length = bytes(text).length;
        for (var i = 0; i < length; i++) {
            byte char = bytes(text)[i];
            assembly {
                char := byte(0,char)
                if and(gt(char,0x60), lt(char,0x6E))
                { char:= add(0x7B, sub(char,0x61)) }
                if iszero(eq(char, 0x20))
                {mstore8(add(add(text,0x20), mul(i,1)), sub(char,26))}
            }
        }
        emit Result(text);
    }
}
----

该合约实现了ROT26密码，该密码将每个字符移位26位（即不执行任何操作）。同样，在此不需要了解合约程序中的汇编过程。更简单地说，攻击者可以将以下合约链接起来并具有相同的效力：

[source,solidity,linenums]
----
contract Print{
    event Print(string text);

    function rot13Encrypt(string text) public {
        emit Print(text);
    }
 }
----

如果将任何一个这两个合约的地址输入合约的构造函数，`encryptPrivateData` 函数只会产生一个打印出未加密的私有数据的事件。

虽然在这个示例里面，在构造函数中设置了一个类似库的合约，通常特权用户（例如所有者）可以更改库合约地址。如果链接合约不包含被调用的函数，那么fallback函数将被执行。例如，在这行：pass:[<code>encryptionLibrary.rot13&#x200b;Encrypt()</code>]，如果合约指定的 `encryptionLibrary` 是:

[source,solidity,linenums]
----
 contract Blank {
     event Print(string text);
     function () {
         emit Print("Here");
        //将恶意代码放在此处，它将运行
     }
 }
----

然后会发出带有 `Here` 文本的事件。因此，如果用户可以更改库合约，原则上他们可以在不知不觉中使得其他用户运行任意代码。

[WARNING]
====
此处的合约仅用于说明目的，并且不代表适当的加密。它们不应该用于加密。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc29")))
====

[role="notoc"]
==== 预防技术

((("external contract referencing security threat","preventative techniques")))如前所述，安全的合约可以（在某些情况下）通过恶意方式进行部署。审核员可以公开验证合约，并允许其所有者以恶意方式将其部署，这将导致经过公开审核的合约仍存在漏洞或恶意意图。

有许多技术可以防止出现这些情况。

一种技术是使用 `new` 关键字创建合约。在前面的示例中，构造函数可以写为：

[source,solidity]
----
constructor() {
    encryptionLibrary = new Rot13Encryption();
}
----

这样，在部署时就可以创建引用合约的实例时间，并且部署者无法替换 `Rot13Encryption` 合约而不更改它。

另一种解决方案是对外部合约地址进行硬编码。

通常，调用外部合约的代码应始终为经过仔细审核的。作为开发人员，在定义外部合约时，考虑将合约地址公开是一个好主意（未发生在下一节的蜜罐示例中），以便用户轻松检查合约所引用的代码。相反，如果合约包含私有变量的合约地址，可能表示这里面的行为包含恶意（如真实示例所示）。如果用户可以更改一个用于调用外部函数的合约地址，那么很重要的（在分布式系统中范围）是需要实施时间锁定和/或投票机制，以允许用户查看被更改的代码，或让参与者有机会选择使用/不使用新合约地址。

==== 真实案例：可再入的蜜罐

((("external contract referencing security threat","real-world example: reentrancy honey pot", id="ix_09smart-contracts-security-asciidoc30", range="startofrange")))((("honey pots", id="ix_09smart-contracts-security-asciidoc31", range="startofrange")))((("reentrancy honey pot security threat", id="ix_09smart-contracts-security-asciidoc32", range="startofrange")))主网上已发布了许多最新的蜜罐（Honey Pot）合约。这些合约试图诱使以太坊黑客来攻击合约，但最终导致他们在合约中输掉以太币而不是所预期的获利。一个例子就是通过用恶意合约替换构造函数中的预期的合约。这段代码可以在下面找到 http://bit.ly/2JtdqRi[here]:

[source,solidity,linenums]
----
pragma solidity ^0.4.19;

contract Private_Bank
{
    mapping (address => uint) public balances;
    uint public MinDeposit = 1 ether;
    Log TransferLog;

    function Private_Bank(address _log)
    {
        TransferLog = Log(_log);
    }

    function Deposit()
    public
    payable
    {
        if(msg.value >= MinDeposit)
        {
            balances[msg.sender]+=msg.value;
            TransferLog.AddMessage(msg.sender,msg.value,"Deposit");
        }
    }

    function CashOut(uint _am)
    {
        if(_am<=balances[msg.sender])
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,"CashOut");
            }
        }
    }

    function() external payable{}

}

contract Log
{
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }

    Message[] public History;
    Message LastMsg;

    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr;
        LastMsg.Time = now;
        LastMsg.Val = _val;
        LastMsg.Data = _data;
        History.push(LastMsg);
    }
}
----

这个 http://bit.ly/2Q58VyX[post]由一位reddit用户发布的帖子解释了他们如何在该合约中损失了1个以太币通过尝试利用预期会出现在合约中的重入攻击缺陷
(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc32")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc31")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc30"))).(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc28")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc27")))

=== 短地址/参数攻击

((("security (smart contracts)","short address/parameter attack")))((("short address/parameter attack")))此攻击并不对Solidity合约本身进行攻击，但是攻击可能与它们交互的第三方应用程序上。本节为了完整起见，添加了此部分，以使读者了解参数设置如何可以被合约操纵。

有关更多示例，请参阅
http://bit.ly/2yKme14[&#x201c;The ERC20 Short Address Attack Explained&#x201d;], +
http://bit.ly/2yFOGRQ[&#x201c;ICO Smart Contract Vulnerability: Short Address Attack&#x201d;], + 
或者 http://bit.ly/2CQjBhc[Reddit post].

[role="notoc"]
==== 漏洞

((("short address/parameter attack","vulnerability")))当将参数传递给智能合约时，参数的编码需要根据ABI规范 http://bit.ly/2Q5VIG9[ABI specification] 进行。这里可以发送参数编码短于预期的参数长度（例如，发送地址仅为38个十六进制字符（19个字节），而不是标准的40个十六进制字符（20个字节）。在这种情况下，EVM会将零添加到编码参数的末尾以组成预期的长度。

这将成为一个问题，特别是当第三方应用程序未验证输入时。最明显的例子是一个交易所不验证那些ERC20通证的地址而完成用户的提款请求时。该示例的更多内容Peter Vessenes的帖子中有详细介绍， http://bit.ly/2Q1ybpQ[&#x201c;The ERC20 Short Address Attack Explained&#x201d;].

考虑标准 http://bit.ly/2CUf7WG[ERC20]的 +transfer+ 函数界面，注意参数顺序：

[source,solidity]
----
function transfer(address to, uint tokens) public returns (bool success);
----

现在考虑一个持有大量通证的交易所（比方说REP）和希望提取其100个通证份额的用户。用户将提交其账户地址 `0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead`，和要提取通证的数量100。交易所将对这些信息进行编码其中参数的顺序是 pass:[ <code><span class="keep-together">transfer</span></code> ]函数指定；即，先是 `地址` 然后是 `通证`。编码结果为：

----
a9059cbb000000000000000000000000deaddeaddea \
ddeaddeaddeaddeaddeaddeaddead0000000000000
000000000000000000000000000000000056bc75e2d63100000
----

开头的4个字节（`a9059cbb`）是 `transfer` http://bit.ly/2RmueMP[function 签名/选择器]，接下来的32个字节是地址，而最后的32个字节是格式为uint256的变量，代表通证的数量。请注意，最后的十六进制 `56bc75e2d63100000` 对应于100通证（小数点后18位，由 `REP` 通证指定）
pass:[<span class="keep-together">contract</span>]).

现在让我们看看如果发送一个地址缺少1个字节（2个十六进制数字）。具体来说，假设攻击者发送 `0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde` 作为地址（丢失最后两位数字）和相同的 `100` 通证要提取。如果交易所不验证此输入，它将被编码为：

----
a9059cbb000000000000000000000000deaddeaddea \
ddeaddeaddeaddeaddeaddeadde000000000000000
0000000000000000000000000000000056bc75e2d6310000000
----

这里的区别很微妙。请注意，编码末尾已经添加了 `00`，以弥补发送地址的短缺部分。当这被发送到智能合约时，`address` 参数将被读取为 `0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00`，而该值将被读成如 `56bc75e2d6310000000`（注意两个额外的 ++0++ ）。这个值是现在变成了25600个通证（该值已乘以 `256`）。在这个例子，如果交易所持有这么多通证，那么用户将提取 `25600` 个通证（交易所认为用户只是在提取 `100`）到修改后的地址。显然，攻击者不会拥有在此示例中的修改后的地址，但如果攻击者要生成任何以 ++0++ 结尾的地址（可以很容易地用暴力破解）并使用这个生成的地址，他们可以从毫无防护的交易所里面盗取通证。

[role="notoc"]
==== 预防技术

((("short address/parameter attack","preventative techniques"))) 外部应用程序中的所有输入参数都应先经过验证再将它们发送到区块链上。我们需要注意，参数的排序在这里起着重要作用。填充过程仅在最后发生，对智能合约中的参数进行仔细排序可以降低这种形式的攻击。

=== 未检查的调用返回值

((("calls, external", id="ix_09smart-contracts-security-asciidoc33", range="startofrange")))((("external calls", id="ix_09smart-contracts-security-asciidoc34", range="startofrange")))((("security (smart contracts)","unchecked CALL return value threat", id="ix_09smart-contracts-security-asciidoc35", range="startofrange")))((("unchecked CALL return value security threat", id="ix_09smart-contracts-security-asciidoc36", range="startofrange")))在Solidity中有多种执行外部调用的方法。发送以太坊到外部账户通常是通过 `transfer` 方法执行的。但是，也可以使用 `send` 函数，并且更多用途的外部调用 `CALL` 操作码可以直接在Solidity中使用。 `call` 和 `send` 函数返回一个逻辑值，表明是否调用成功或失败。因此，这些函数有一个简单的警告，如果执行这些函数的交易将不会恢复外部调用（通过 `call` 或 `send` 初始化）失败；而是函数仅返回 `false`。一个常见的错误是如果外部调用失败，开发人员希望交易将发生还原过程，并且不检查返回值。

有关更多信息，请参见 http://www.dasp.co/#item-4[DASP Top 10 of 2018]上的＃4和 http://bit.ly/2RnS1vA[&#x201c;Scanning Live Ethereum Contracts for the &lsquo;Unchecked-Send&rsquo; Bug&#x201d;].

[role="notoc"]
==== 漏洞

((("unchecked CALL return value security threat","vulnerability"))) 考虑以下示例：

[source,solidity,linenums]
----
  1 contract Lotto {
  2 
  3     bool public payedOut = false;
  4     address public winner;
  5     uint public winAmount;
  6 
  7     // ... extra functionality here
  8 
  9     function sendToWinner() public {
 10         require(!payedOut);
 11         winner.send(winAmount);
 12         payedOut = true;
 13     }
 14 
 15     function withdrawLeftOver() public {
 16         require(payedOut);
 17         msg.sender.send(this.balance);
 18     }
 19 }
----

这代表了类似于乐透的合约，其中 `winner` 接收以太币的 `winAmount`，通常还会剩下一点让任何人提现。

该漏洞存在于第11行，其中使用了 `send` 而不检查函数的响应。在这个简单的例子中，一个 `winner` 的交易失败（由于用尽燃料或合约故意失败并调用fallback函数）允许将payedOut设置为true而不管是否发送了以太币。在这种情况下，任何人都可以通过 `withdrawLeftOver` 函数获得 `winner` 的奖金。

[role="notoc"]
==== 预防技术

((("unchecked CALL return value security threat","preventative techniques"))) 只要有可能，应该使用 `transfer` 函数而不是 `send`，因为如果外部交易还原，则 `transfer` 将还原。如果需要 `send`，需要总是检查返回值。

一个更可靠的 http://bit.ly/2CSdF7y[建议]是采用一种 _提款模式_。在此解决方案中，每个用户必须调用一个独立的 +withdraw+ 函数处理发送合约中的以太币并处理发送交易失败的后果。这个想法是在逻辑上将外部发送功能与其余的代码库隔离，并将潜在失败交易的负担放在最终用户调用 +withdraw+ 函数中。

==== 真实案例：Etherpot 和 King of the Ether

http://bit.ly/2OfHalK[Etherpot] ((("Etherpot smart contract lottery")))((("King of the Ether")))((("unchecked CALL return value security threat","real-world example: Etherpot and King of the Ether")))是一个智能合约彩票项目，与前面提到的示例合约类似。该合约的问题主要是由于不当使用区块哈希（仅可使用最后的256个块哈希；请参阅Aakil Fernandes 的文章 http://bit.ly/2Jpzf4x[post]关于Etherpot如何无法正确使用区块哈希）。但是这个合约还有未经检查的调用返回值问题。考虑一下<<lotto_security>>中的函数 `cash`。

[[lotto_security]]
.lotto.sol: Code snippet
====
[source,solidity,linenums]
----
  1 ...
  2   function cash(uint roundIndex, uint subpotIndex){
  3 
  4         var subpotsCount = getSubpotsCount(roundIndex);
  5 
  6         if(subpotIndex>=subpotsCount)
  7             return;
  8 
  9         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);
 10 
 11         if(decisionBlockNumber>block.number)
 12             return;
 13 
 14         if(rounds[roundIndex].isCashed[subpotIndex])
 15             return;
 16         //Subpots can only be cashed once. This is to prevent double payouts
 17 
 18         var winner = calculateWinner(roundIndex,subpotIndex);
 19         var subpot = getSubpot(roundIndex);
 20 
 21         winner.send(subpot);
 22 
 23         rounds[roundIndex].isCashed[subpotIndex] = true;
 24         //Mark the round as cashed
 25 }
 26 ...
----
====

请注意，在第21行，`send` 函数的返回值没有检测，然后在下一行设置了一个逻辑值，用于判断奖金已经发送给了获胜者。此错误可能会导致中标者没有收到以太币，但是合约的状态表示中奖者已被支付。

此错误的更严重版本发生在项目 http://bit.ly/2ACsfi1[King of the Ether]。一个极好的 http://bit.ly/2ESoaub[post-mortem] 详细说明了未经检查失败的 `send` 如何被用于攻击 pass:[<span class="keep-together">合约</span>]的。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc36")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc35")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc34")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc33")))

[[frontrunning_security]]
=== 比赛条件/抢跑

((("front-running attacks", id="ix_09smart-contracts-security-asciidoc37", range="startofrange")))((("security (smart contracts)","race conditions/front running threat", id="ix_09smart-contracts-security-asciidoc38", range="startofrange")))((("race conditions", seealso="front-running security threat; reentrancy attack")))对其他合约的外部调用与底层区块链的多用户性质相结合，产生了各种潜在的 Solidity 陷阱，用户通过这些陷阱 _竞争_ 执行代码以获得意外状态。重入（本章前面已有讨论）就是这种竞争条件的一个例子。在本节中，我们将讨论其他类型的竞争条件这可能发生在以太坊区块链上。 有很多关于这个主题的好帖子，包括&#x201c;Race Conditions&#x201d; 还有 http://bit.ly/2yFesFF[Ethereum Wiki], http://www.dasp.co/#item-7[#7 on the DASP Top10 of 2018], 和 http://bit.ly/2Q6E4lP[Ethereum Smart Contract Best Practices]。

[role="notoc"]
==== 漏洞

((("front-running attacks","vulnerability")))与其他大多数区块链一样，以太坊节点汇集交易并把交易打包进区块。这些交易的有效性仅当矿工解决了共识问题（当前 http://bit.ly/2yI5Dv7[Ethash] PoW 用于以太坊）。挖出区块的矿工还可以从交易池中选择哪些交易将包含在区块中，通常根据每笔交易的 `gasPrice` 排序。这是潜在的攻击媒介。一个攻击者可以监视交易池中可能存在的包含问题解决方案的交易，并修改或撤消方案解决者的许可或更改合约中的状态，不利于解决者。然后，攻击者可以从此交易中获取数据，并创建自己的交易，并使用更高的 `gasPrice`，因此他们的交易可以被包含在原始交易之前的一个区块中。

让我们用一个简单的例子看看这是如何工作的。考虑一下<<findthishash_security>>中展示的合约。

[[findthishash_security]]
.FindThisHash.sol
====
[source,solidity,linenums]
----
contract FindThisHash {
    bytes32 constant public hash =
      0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;

    constructor() external payable {} // load with ether

    function solve(string solution) public {
        // If you can find the pre-image of the hash, receive 1000 ether
        require(hash == sha3(solution));
        msg.sender.transfer(1000 ether);
    }
}
----
====

假设该合约包含1,000个以太币。如果用户可以找到以下SHA-3哈希的原像：

----
0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a
----

就可以提交解决方案并提出1,000个以太币。假设有一位使用者找出解决方案是 `Ethereum!`。他们调用 `solve` 函数并将 `Ethereum!` 作为参数提交。不幸的是，一个精明的攻击者一直在监视提交解决方案的交易池。他们看到此解决方案，检查其有效性，然后提交一个相同的交易，其 `gasPrice` 比原始交易高得多的交易。挖出区块的矿工可能会由于攻击者的交易 `gasPrice` 较高而先挖掘他们的交易，而不是原始解决者提交的交易。攻击者将拿走1,000以太币，而解决问题的用户将一无所获。请记住，在这种类型的 `先行攻击` 漏洞中，矿工被独特地激励自己进行攻击（或者被贿赂用昂贵的费用来运行这些攻击）。不应低估攻击者本身就是矿工的可能性。

[role="notoc"]
==== 预防技术

((("front-running attacks","preventative techniques"))) 有两种类型的参与者可以执行以下类型的前端攻击：用户（修改其交易的 `gasPrice`）和矿工本身（用户可以重新按照他们认为合适的顺序排列区块中的交易）。合约受到第一种攻击（用户）导致的问题要比合约受到第二种攻击（矿工）严重的多，因为矿工只能当他们挖出一个块时能执行攻击，这对于任何针对特定块的单个矿工来说都是不可能的。在这里，我们将列出一些解决措施，可以缓解这两类的攻击者。

一种方法是在 `gasPrice` 上设置上限。这样可以防止用户超过上限提高 `gasPrice` 并获得优惠的交易订单。此措施只能防止第一类攻击者（特定用户）。在这种情况下，矿工仍然能攻击合约，因为他们可以对区块中的交易按他们喜欢的方式排序，而不管燃料价格如何。

一种更可靠的方法是使用 http://bit.ly/2CUh2KS[commit–reveal]方案。这样的方案要求用户发送具有隐藏信息（通常是哈希）的交易。等到交易已包含在一个区块中后，用户再发送交易显示已发送的数据（显示阶段）。这个方法可以防止矿工和用户进行抢跑交易，因为他们无法确定交易内容。但是，这种方法无法隐藏交易价值（在某些情况下是需要隐藏的宝贵信息）。而ENS https://ens.domains/[ENS] 智能合约允许用户发送交易，并在提交的数据中包含他们愿意支付的以太币数量。然后，用户可以发送一个交易包含任意金额。在显示阶段，用户可以收回在交易中发送的金额和他们愿意支付的金额之间的差值。

另一个由 ((("submarine sends"))) Lorenz Breidenbach，Phil Daian，Ari Juels和FlorianTramèr 提出的建议是使用 http://bit.ly/2SygqQx[&#x201c;潜水艇发送s&#x201d;]。这个想法的有效实现需要 `CREATE2` 操作码，目前尚未被以太坊系统采用，但可能在未来的硬分叉中实现。

==== 真实案例：ERC20和Bancor

((("ERC20 token standard","front-running vulnerability")))((("front-running attacks","real-world examples: ERC 20 and Bancor")))http://bit.ly/2CUf7WG[ERC20标准]以在以太坊上构建通证而闻名。这个标准具有潜在的抢跑漏洞，具体是在 `approve` 函数之中。 http://bit.ly/2DbvQpJ[Mikhail Vladimirov和Dmitry Khovratovich]对此做了很好的解释，包括漏洞的详情和缓解攻击的方法。

该标准将 `approve` 函数指定为：

[source,solidity]
----
function approve(address _spender, uint256 _value) returns (bool success)
----

此功能允许用户批准其他用户代表自己传送通证。抢跑漏洞发生在以下情况中：用户Alice 批准，即 _approves_ 她的朋友Bob可以支付100个通证。Alice后来决定她要撤消Bob的批准，例如说，100个通证，因此她创建了一个交易来设置Bob的额度到50个通证。Bob一直在仔细观察区块链，他发现了这项交易并自己建立了一个支付100通证的交易。并且他在交易中使用的 `gasPrice` 高于Alice的交易，这样就可以覆盖她的交易。一些 `approve` 的实现版本将允许鲍勃转移他的100个通证，然后在Alice的交易完成后，会重置Bob的批准额度为50个通证，实际上使Bob可以使用150个通证。

((("Bancor"))) 另一个突出的真实示例是 https://www.bancor.network/[Bancor] 。伊万·博加蒂（Ivan Bogatyy）和他的团队记录了最初的Bancor实施获利的攻击。他的博客 http://bit.ly/2EUlLzb[blog post] 和讲座 http://bit.ly/2yHgkhs[DevCon3 talk]详细讨论这个过程。实质上，通证的价格是根据交易额确定；用户可以通过查看Bancor交易的交易池并进行抢跑交易以从价格差别中获利。 Bancor团队已解决了此攻击。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc38")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc37")))

=== 拒绝服务（DoS）

((("denial of service (DoS) attacks", id="ix_09smart-contracts-security-asciidoc39", range="startofrange")))((("security (smart contracts)","denial of service attacks", id="ix_09smart-contracts-security-asciidoc40", range="startofrange"))) 此类别非常广泛，但从根本上讲包含的攻击是用户可以在一段时间内使合约无法执行，或者在某些情况下是永久的。某些极端情况可以永远将以太币困在这些合约中，就像<<multisig_secondhack>>。

[role="notoc"]
==== 漏洞

((("denial of service (DoS) attacks","vulnerability"))) 合约可以通过多种方式失效。在这里，我们仅强调一些不太明显的Solidity中可能导致DoS漏洞的编码模式：

由外部操作的映射或数组循环::
通常此模式出现在当所有者希望分配通证给投资者时，类似 `distribute` 架构的函数，如本例合约所示：
+
[source,solidity,linenums]
----
contract DistributeTokens {
    address public owner; // gets set somewhere
    address[] investors; // array of investors
    uint[] investorTokens; // the amount of tokens each investor gets

    // ... extra functionality, including transfertoken()

    function invest() external payable {
        investors.push(msg.sender);
        investorTokens.push(msg.value * 5); // 5 times the wei sent
        }

    function distribute() public {
        require(msg.sender == owner); // only owner
        for(uint i = 0; i < investors.length; i++) {
            // here transferToken(to,amount) transfers "amount" of 
            // tokens to the address "to"
            transferToken(investors[i],investorTokens[i]);
        }
    }
}
----
+
请注意，此合约中的循环在一个数组上运行，该数组可以是人为扩展的。攻击者可以创建许多用户帐户，从而导致 `investor` 数组很大。原则上，可以这样做，以便执行 +for+ 循环所需的燃料值超出了区块燃料的上限值，实质上导致 `distribute` 函数无法使用。

所有者操作::
((("Initial Coin Offerings (ICOs)","DoS attacks and"))) 另一种常见模式是所有者拥有合约中的特定特权，并且必须执行某些任务才能推进合约进行到下一个状态。一个示例是初始通证发行（ICO）的合约要求所有者最终确定 `finalize` 合约，然后才可以允许通证转让。例如：
+
[source,solidity,linenums]
----
  1 bool public isFinalized = false;
  2 address public owner; // gets set somewhere
  3 
  4 function finalize() public {
  5     require(msg.sender == owner);
  6     isFinalized == true;
  7 }
  8 
  9 // ... extra ICO functionality
 10 
 11 // overloaded transfer function
 12 function transfer(address _to, uint _value) returns (bool) {
 13     require(isFinalized);
 14     super.transfer(_to,_value)
 15 }

...
----
+
在这种情况下，如果特权用户丢失其私钥或变成无效账户，整个通证合约将无法使用。在这种情况下所有者不能调用 pass:[ <span class="keep-together"><code>finalize</code></span> ]通证不能被转让；通证生态系统的全部操作取决于一个账户地址。

基于外部调用的进度状态:: 合约中有时会写这样，要发展到新状态，需要将以太币发送到地址，或等待来自外部源的某些输入。这些模式会在外部调用失败或由于外部因素阻止调用时，会导致DoS攻击成功。在发送以太币的示例中，用户可以创建合约不接受以太币。如果合约要求提取以太币以进入新的状态（请考虑一个限时合约，要求所有以太币在被提出之后，才能再次可用），合约将永远不会达到新的状态，因为永远无法将以太币发送到用户的不接受以太币的合约中。

[role="notoc"]
==== 预防技术

((("denial of service (DoS) attacks","preventative techniques"))) 在第一个示例中，合约不应遍历可以由外部用户人为操纵的数据结构。建议采用提款的模式，即每个投资者可以调用 +提款+ 函数来独立提取通证。

在第二个示例中，需要特权用户才能更改合约的状态。在这样的例子中，故障保护可以在在合约所有者丧失管理能力时使用。一种解决方案是使所有者成为多重签名合约。另一种解决方案是使用时间锁定：在给出第5行 +require+ 的示例中，可以包含一个基于时间的机制，例如 `require（msg.sender == owner || now&gt; unlockTime）`，允许任何用户在 `unlockTime` 指定的一段时间后完成。这类缓解技术的例子也可以在第三示例中使用。如果需要外部调用以进入新状态，以防止它们可能的故障并可能添加基于时间的状态变化，以防期望的调用永远不会到来。

[NOTE]
====
当然，这些建议有一些中心化的替代方案：可以添加一个 `maintenanceUser` ，该用户可以在必要的情况下，修复基于DoS的攻击数值可能会出现问题。通常这些种类的合约中，由于这样一个实体的权利，而导致信任问题。
====

==== 真实案例：GovernMental

http://governmental.github.io/GovernMental/[GovernMental] ((("denial of service (DoS) attacks","real-world example: GovernMental")))((("GovernMental Ponzi scheme","DoS vulnerability"))) 是一个老的庞氏骗局，其中积累了大量的以太币（一次为1,100个以太币）。不幸的是，它容易受到本节中提到的DoS漏洞的影响。 etherik的帖子 http://bit.ly/2DcgvFc[Reddit post]描述了合约如何要求删除大的映射以便提现以太币。删除该映射需要的燃料成本超过了区块燃料上限，因此不可能提取1,100以太币。合约地址是 http://bit.ly/2Oh8j7R[+0xF45717552f12Ef7cb65e95476F217Ea008167Ae3+]，而且你可以从 http://bit.ly/2Ogzrnn[+0x0d80d67202bd9cb6773df8dd2020e719&thinsp;0a1b0793e8ec4fc105257e8128f0506b+] 中看到交易，最终1,100以太币是通过使用以下交易获得的2.5M燃料gas（当区块燃料限制已上升到足以允许此类交易时）。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc40")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc39")))

=== 区块时间戳操作

((("block timestamp manipulation security threat", id="ix_09smart-contracts-security-asciidoc41", range="startofrange")))((("security (smart contracts)","block timestamp manipulation threat", id="ix_09smart-contracts-security-asciidoc42", range="startofrange"))) 区块的时间戳在过去已用于多种应用程序中，例如随机数的熵（请参见<<entropyillusion_security>>了解更多信息），在一段时间内锁定资金，以及与时间相关的状态改变条件判断语句。矿工有一定能力对时间戳进行调整，这种能力可能会很危险，尤其是在合约中错误使用区块的时间戳的情况下。

有用的参考资料包括 http://bit.ly/2OdUC9C[the Solidity docs] 和 http://bit.ly/2CQ8gh4[Joris Bontje's Ethereum Stack Exchange question] 的问题解答。

[role="notoc"]
==== 漏洞

((("block timestamp manipulation security threat","vulnerability")))`block.timestamp` 及其别名 `now` 可以由矿工操纵，如果他们有这样做的动力。让我们构建一个简单的游戏，如<<roulette_security>>，那么将很容易受到矿工的攻击。

[[roulette_security]]
.roulette.sol
====
[source,solidity,linenums]
----
contract Roulette {
    uint public pastBlockTime; // forces one bet per block

    constructor() external payable {} // initially fund contract

    // fallback function used to make a bet
    function () external payable {
        require(msg.value == 10 ether); // must send 10 ether to play
        require(now != pastBlockTime); // only 1 transaction per block
        pastBlockTime = now;
        if(now % 15 == 0) { // winner
            msg.sender.transfer(this.balance);
        }
    }
}
----
====

这个合约的行为就像是简单的彩票。每个区块的一笔交易可以下注10以太币，就有机会赢得合约的余额。但这里的假设是 `block.timestamp` 的最后两位数字是均匀分布的。如果真是这样，那么就有1/15的机会赢得此彩票。

但是，我们知道，在这种情况下矿工可以根据需要调整时间戳，如果合约中有足够的以太币，挖掘区块的矿工有动机选择时间戳，以使 `block.timestamp` 或 `now` 对15取余数为0。这样可以使他们赢得锁定在该合约中的以太币和区块的奖励。因为每个区块只有一个人可以下注，这也容易受到抢跑攻击（请参阅<<frontrunning_security>>了解更多信息）。

实际上，区块时间戳单向增加，因此矿工不能选择任意的区块时间戳（它们必须晚于它们之前的时间戳）。矿工也不能把区块的时间设定到太远的未来，否则这些区块会被网络所拒绝（节点将不会验证时间戳在未来的区块）。

[role="notoc"]
==== 预防技术

((("block timestamp manipulation security threat","preventative techniques"))) 不应将区块时间戳用于熵或生成随机数字的过程-即，它们不应成为决定因素（直接或通过一些推导）来赢得游戏或更改重要的状态。

有时需要对时间敏感的逻辑，例如，用于解锁合约（时间锁定），在几周后完成ICO，或确定终止日期。有时建议使用区块高度 http://bit.ly/2OdUC9C[`block.number`] 和平均区块时间来估计时间；如果是 `10秒` 的区块时间， `1周` 大约等于 `60480个区块`。因此，指定可以更改合约状态的区块编号可以更加安全，因为矿工无法轻松操纵区块编号。 http://bit.ly/2AAebFr[BAT ICO] 合约采用了这种策略。

这也许是不必要的，如果合约不是特别担心矿工对区块时间戳的操纵，但这是需要在合约开发中所了解的。

==== 真实示例：GovernMental

http://governmental.github.io/GovernMental/[GovernMental], ((("block timestamp manipulation security threat","real-world example: GovernMental")))((("GovernMental Ponzi scheme","block timestamp-based attack")))上面提到的旧庞氏骗局也容易受到基于时间戳的攻击。每一回合，合约会支付给最后一个加入（至少一分钟）的玩家。因此，作为矿工的玩家可以调整时间戳（到未来的时间，以使其看起来像过去了一分钟），从而使得他们开起来是最后一分钟加入比赛的玩家（虽然事实并非如此）。有关更多详细信息，请参见下面的资料：Tanya pass:[<span class="keep-together">Bahrynovska</span>]撰写的 http://bit.ly/2Q1AMA6[&#x201c;History of Ethereum Security Vulnerabilities, Hacks and Their Fixes&#x201d; post] 一文。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc42")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc41")))

=== 仔细编写合约的构造函数

((("constructor function","contract name modification security threat")))((("security (smart contracts)","constructors and contract name-change threat")))构造函数是一些特殊的函数，经常在初始化合约时执行关键，特殊的任务。在Solidity v0.4.22之前，构造函数被定义为和包含它们的合约具有相同名字的函数。在这种情况下，当合约名称在开发中被修改时，如果构造函数名称并未更改，那么它将变为普通的，可调用的函数。你可以想象，这可以导致（并具有）一些有趣的合约漏洞。

为了进一步了解，读者可能有兴趣尝试 https://github.com/OpenZeppelin/ethernaut[Ethernaut challenges]（特别是Fallout级别）。

[role="notoc"]
==== 漏洞

((("constructor/contract name modification security threat","vulnerability")))((("contract name modification/constructor security threat","vulnerability"))) 如果合约名称被修改，或者有错字在构造函数的名称里面，使其与合约的名字不符，构造函数将表现得像一个正常的函数。这个可以导致糟糕的后果，特别是如果构造函数可以执行特权操作。考虑以下合约：

[source,solidity,linenums]
----
contract OwnerWallet {
    address public owner;

    // constructor
    function ownerWallet(address _owner) public {
        owner = _owner;
    }

    // Fallback. Collect ether.
    function () payable {}

    function withdraw() public {
        require(msg.sender == owner);
        msg.sender.transfer(this.balance);
    }
}
----

该合约收集以太币，仅允许合约所有者通过调用 `withdraw` 函数提现。出现此问题是因为构造函数的名称与合约的名称不完全相同：第一个字母不一样！因此，任何用户可以调用 `ownerWallet` 函数，将自己设置为所有者，然后通过调用 `withdraw` 提取合约中所有的以太币。

[role="notoc"]
==== 预防技术

((("constructor/contract name modification security threat","preventative techniques")))((("contract name modification/constructor security threat","preventative techniques")))此问题已在Solidity编译器版本0.4.22中得到解决。这个版本引入了 `constructor` 关键字，可以指定构造函数，而不是要求函数匹配合约名称。推荐使用此关键字指定构造函数来防止命名问题。

==== 真实示例：Rubixi

http://bit.ly/2ESWG7t[Rubixi] ((("constructor/contract name modification security threat","real-world example: Rubixi")))((("contract name modification/constructor security threat","real-world example: Rubixi")))((("Rubixi pyramid scheme"))) 是另一种展示了这种漏洞的例子。它最初称为 `动态金字塔`，但合约名称在部署到 `Rubixi` 之前已更改。不过构造函数的名称未更改，可以允许任何用户成为创建者。与此错误相关的一些有趣的讨论可以在下面找到 http://bit.ly/2P0TRWw[Bitcointalk] 。最终，它允许用户为创建者身份而挑战并从金字塔骗局中获取费用。有关此特定漏洞的更多详细信息可以在 http://bit.ly/2Q1AMA6[&#x201c;History of Ethereum Security Vulnerabilities, Hacks and Their Fixes&#x201d;] 中找到。

=== 未初始化的存储指针

((("security (smart contracts)","uninitialized storage pointer threat", id="ix_09smart-contracts-security-asciidoc43", range="startofrange")))((("storage pointers, uninitialized", id="ix_09smart-contracts-security-asciidoc44", range="startofrange")))((("uninitialized storage pointers security threat", id="ix_09smart-contracts-security-asciidoc45", range="startofrange")))  EVM将数据存储为存储器或内存。准确理解这一实现方式以及函数本地变量的默认类型是在开发合约时，强烈建议你了解的。这是因为不适当地初始化变量，有可能产生有漏洞的合约。

要了解有关EVM中存储和内存的更多信息，请参见Solidity文档，网址为 http://bit.ly/2OdUU0l[data location]，  + 
http://bit.ly/2JslDWf[layout of state variables in storage]， + 
和 http://bit.ly/2Dch2Hc[layout in memory]。

[NOTE]
====
本节基于一个很好的博客文章 http://bit.ly/2ERI0pb[post by Stefan Beyer]。在Stefan的启发下，可以在此找到关于此主题的更多资料 http://bit.ly/2OgxPtG[Reddit thread]。
====

[role="notoc"]
==== 漏洞

((("uninitialized storage pointers security threat","vulnerability", id="ix_09smart-contracts-security-asciidoc46", range="startofrange")))函数内的局部变量根据其类型默认为存储或内存。未初始化的本地存储变量可能包含合约中其他存储变量的值；这一事实可能会导致无意的漏洞，或者恶意利用。

让我们考虑一下相当简单的名字注册合约<<nameregistrar_security>>。

[[nameregistrar_security]]
.NameRegistrar.sol
====
[source,solidity,linenums]
----
  1 // A locked name registrar
  2 contract NameRegistrar {
  3 
  4     bool public unlocked = false;  // registrar locked, no name updates
  5 
  6     struct NameRecord { // map hashes to addresses
  7         bytes32 name;
  8         address mappedAddress;
  9     }
 10 
 11     // records who registered names
 12     mapping(address => NameRecord) public registeredNameRecord;
 13     // resolves hashes to addresses
 14     mapping(bytes32 => address) public resolve;
 15 
 16     function register(bytes32 _name, address _mappedAddress) public {
 17         // set up the new NameRecord
 18         NameRecord newRecord;
 19         newRecord.name = _name;
 20         newRecord.mappedAddress = _mappedAddress;
 21 
 22         resolve[_name] = _mappedAddress;
 23         registeredNameRecord[msg.sender] = newRecord;
 24 
 25         require(unlocked); // only allow registrations if contract is unlocked
 26     }
 27 }
----
====

这个简单的名称注册合约只有一个函数。当合约是 `unlocked` 状态，它允许任何人注册一个名称（作为 `bytes32` 哈希值）并将该名称映射到地址。注册合约最初被锁定，第25行上的 `require` 阻止了 `register` 函数添加名称记录。该合约看起来似乎无法使用，因为没有办法解锁注册表！但是，这里存在一个漏洞可以不管 `unlocked` 变量如何，都可以进行名称注册。

// TODO: Andreas to check if this introduction is required as another section
// of the book may be able to be referenced. The language may also need to be
// adjusted.

要讨论此漏洞，首先我们需要了解存储方式是如何在Solidity中使用的。作为高级概述（没有任何适当的技术细节-我们建议阅读Solidity文档以获取适当信息内容），状态变量按它们在合约中出现的顺序存储在 _slots_ 中（它们可以分组在一起，但是不在此例子中，因此我们不必为此担心）。因此，`unlocked` 存在于 `slot[0]`， `slot[1]` 中存储的是 `registeredNameRecord`，`resolve` 存在 `slot[2]` 等。这些插槽的大小均为32个字节（映射增加了复杂性，我们暂时将其忽略）。逻辑值 `unlocked` 为 `false` 的值时，存储内容为 `0x000...0`（64个 ++0++，不包括 `0x`）值为true时的存储内容为 `0x000...1` (63个 ++0++)。如你所见，在此特定示例中，存在一个很大的存储浪费。

下一个难题是默认情况下，Solidity把复杂的数据类型，例如 ++struct++，在存储时将它们初始化为局部变量。因此，第18行的 pass:[<span class="keep-together"><code>newRecord</code></span>]默认为storage。该漏洞是由以下事实造成的： pass:[ <span class="keep-together"><code>newRecord</code></span> ]并未初始化。由于默认为存储，因此将其映射到存储位置 ++slot[0]++，当前包含指向 `unlocked` 的指针。请注意，在第19和20行，我们接着将 `newRecord.name` 设置为 `_name`，将 `newRecord.mappedAddress` 设置为 pass:[ <span class="keep-together"><code>_mappedAddress</code></span> ];这将更新位于 ++slot[0]++ 和 ++slot[1]++ 的存储内容，导致 `unlocked` 的内容和
与 `registeredNameRecord` 相关联的存储内容被修改。

这意味着变量 `unlocked` 可以被直接修改，只需通过 `register` 函数的 `bytes32 _name` 参数。因此，如果 `_name` 的最后一个字节非零，它将修改 `slot[0]` 位置的存储内容，即直接将 `unlocked` 更改为 `true`。这样的 `_name` 值将导致第25行的 `require` 调用成功，因为我们已经设置了 `unlocked` 的值为 `true`。在Remix中尝试一下。注意该函数将被执行，如果你使用以下形式的 `_name`：(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc46")))

----
0x0000000000000000000000000000000000000000000000000000000000000001
----

[role="notoc"]
==== 预防技术

((("uninitialized storage pointers security threat","preventative techniques")))Solidity编译器会显示未初始化的存储变量警告；开发人员在创建智能合约时应注意这些警告。当前版本的Mist（0.10）将不会允许编译这些合约。通常，在处理复杂类型时，建议显式使用 `内存` 或 `存储` 说明符，以确保它们的行为符合预期。

==== 真实案例：OpenAddressLottery和CryptoRoulette Honey Pots

((("OpenAddressLottery honey pot")))((("uninitialized storage pointers security threat","real-world examples: OpenAddressLottery and CryptoRoulette honey pots")))一个名为OpenAddressLottery的蜜罐合约 http://bit.ly/2AAVnWD[ +OpenAddressLottery+ ] ，在部署时使用了未初始化的存储变量从一些潜在的黑客那里收集以太币。合约本身相当复杂，我们将分析留给关于这个问题的讨论区 http://bit.ly/2OgxPtG[Reddit thread]，其中对攻击的解释很清楚。

((("CryptoRoulette honey pot")))另一个蜜罐， http://bit.ly/2OfNGJ2[ +CryptoRoulette+ ]，也利用了这个技巧 pass:[<span class="keep-together">尝试</span>]并收集一些以太币。如果你无法弄清楚攻击是如何进行的， + 
请参阅 http://bit.ly/2OVkSL4[&#x201c;An Analysis of a Couple Ethereum Honeypot Contracts&#x201d;] 中对这个合约和其他类似合约的概述。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc45")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc44")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc43")))

=== 浮点数和精度

((("floating-point representation security risk", id="ix_09smart-contracts-security-asciidoc47", range="startofrange")))((("security (smart contracts)","floating-point problem", id="ix_09smart-contracts-security-asciidoc48", range="startofrange")))在撰写本文时（v0.4.24），Solidity不支持定点和浮点数字。这意味着浮点数在Solidity中的表达必须使用整数类型。这个情况如果实施不正确，可能会导致错误和漏洞。

[NOTE]
====
有关更多信息，请参阅 http://bit.ly/2Ogp2Ia[Ethereum Contract Security Techniques and Tips wiki].
====

[role="notoc"]
==== 漏洞

((("floating-point representation security risk","vulnerability")))由于Solidity中没有定点数类型，因此开发人员必须使用标准整数数据类型实现自己定义的数据。这里有许多开发人员可能遇到的陷阱。我们会尝试在本节中重点介绍其中一些。

让我们从一个代码示例开始（为简单起见，我们将忽略本章前面讨论的上下限溢出问题）：

[source,solidity,linenums]
----
  1 contract FunWithNumbers {
  2     uint constant public tokensPerEth = 10;
  3     uint constant public weiPerEth = 1e18;
  4     mapping(address => uint) public balances;
  5 
  6     function buyTokens() external payable {
  7         // convert wei to eth, then multiply by token rate
  8         uint tokens = msg.value/weiPerEth*tokensPerEth;
  9         balances[msg.sender] += tokens;
 10     }
 11 
 12     function sellTokens(uint tokens) public {
 13         require(balances[msg.sender] >= tokens);
 14         uint eth = tokens/tokensPerEth;
 15         balances[msg.sender] -= tokens;
 16         msg.sender.transfer(eth*weiPerEth);
 17     }
 18 }
----

这个简单的通证买卖合约存在一些明显的问题。虽然关于买卖通证的数学计算是正确的，但缺乏浮点数字会给出错误的结果。例如，在购买通证时第8行，如果该值小于1个以太币，则初始除法将导致结果为 `0`，将最终乘法结果保留为 `0`（例如 `200 wei` 除以 `1e18` `weiPerEth` 等于 `0`）。同样，在计算卖出通证时，少于 `10` 个通证的任何数量也将导致 `0个以太币` 的结果。实际上，这里的舍入总是向下的，因此出售 `29个通证` 的结果将是 `2个以太币`。

该合约的问题在于精度仅适用于最近的以太币（即1e18 wei）。这在处理小数点时非常麻烦，比如 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md[ERC20]通证中需要更高精度时。

[role="notoc"]
==== 预防技术

((("floating-point representation security risk","preventative techniques")))在智能合约中保持正确的精度非常重要，特别是在计算比率和利率这些用于经济决策的变量时。

你应确保所使用的任何比率或比率都允许较大分子的分数。例如，我们在示例中使用了 `tokensPerEth` 比率。这里最好使用 `weiPerTokens`，它将是一个大数。为了计算相应数量的通证，我们可以使用 `msg.value/weiPerTokens`。这将给出更精确的结果。

另一种要记住的策略是注意操作顺序。在我们的示例中，购买通证的计算方式是 `msg.value / weiPerEth * tokenPerEth`。注意除法发生在乘法之前。（与某些语言不同，Solicity保证可以按照编写的顺序执行操作。）如果计算先执行乘法然后执行除法即： `msg.value * tokenPerEth / weiPerEth`，则本示例将有更高的精度。

最后，在为数字定义精度时，最好首先将值转换为更高精度，执行所有数学运算，然后最终转换回输出所需的精度。通常使用 ++uint256++ （因为它们最适合gas使用）；这些变量的范围大约60个数量级，其中一些对于数学运算的精度而言足够精细了。这里可能最好在Solidity中保留所有精度较高的变量，然后转换回较低的外部应用程序的精度（本质上，这是 `小数` 变量在ERC20通证合约中的运算方式）。要查看如何完成此操作的示例，我们建议查看 https://github.com/dapphub/ds-math[DS-Math] 。它使用一些时髦的命名（"wads"和"rays"），但是这个概念很有用。

==== 真实案例：Ethstick

((("Ethstick contract")))((("floating-point representation security risk","real-world example: Ethstick")))http://bit.ly/2Qb7PSB[+Ethstick+ 合约] 不使用扩展的精度；但是，它处理的是wei。所以，合约将有四舍五入的问题，但仅在wei级别的精度。它有一些更严重的缺陷，但是这些问题是之前讨论过的，在区块链上获取熵的困难性（请参阅<<entropyillusion_security>>）。关于 +Ethstick+ 合约的进一步讨论我们建议你转到Peter Vessenes的另一篇文章， http://bit.ly/2SwDnE0[&#x201c;Ethereum Contracts Are Going to Be Candy for Hackers&#x201d;]。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc48")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc47")))

=== Tx.Origin身份验证

((("security (smart contracts)","tx.origin authentication threat", id="ix_09smart-contracts-security-asciidoc49", range="startofrange")))Solidity有全局变量 `tx.origin`，它遍历整个调用堆栈，其中的帐户的地址是最初发送调用（或交易）的账户。在智能合约中使用此变量进行身份验证会使合约容易受到网络钓鱼者的攻击。

[NOTE]
====
有关的更多资料，请参阅 dbryson 的以太坊问题 http://bit.ly/2PxU1UM[Stack Exchange question]， + 
Peter Vessenes 的 http://bit.ly/2qm7ocJ[&#x201c;Tx.Origin and Ethereum Oh My!&#x201d;] ， + 
和 Chris Coverdale 的 http://bit.ly/2P3KVA4[&#x201c;Solidity: Tx Origin Attacks&#x201d;]。
====

[role="notoc"]
==== 漏洞

((("tx.origin authentication security threat","vulnerability"))) 合约中使用 `tx.origin` 变量对用户授权会通常容易受到网上诱骗攻击的侵害，诱骗用户对易受攻击的合约执行经过身份验证的操作。

考虑<<phishable_security>>中的简单合约。

[[phishable_security]]
.Phishable.sol
====
[source,solidity,linenums]
----
  1 contract Phishable {
  2     address public owner;
  3 
  4     constructor (address _owner) {
  5         owner = _owner;
  6     }
  7 
  8     function () external payable {} // collect ether
  9 
 10     function withdrawAll(address _recipient) public {
 11         require(tx.origin == owner);
 12         _recipient.transfer(this.balance);
 13     }
 14 }
----
====

注意，在第11行，合约通过 `tx.origin` 授权了 `withdrawAll` 函数。该合约允许攻击者可以创建以下形式的攻击合约：

[source,solidity,linenums]
----
  1 import "Phishable.sol";
  2 
  3 contract AttackContract {
  4 
  5     Phishable phishableContract;
  6     address attacker; // The attacker's address to receive funds
  7 
  8     constructor (Phishable _phishableContract, address _attackerAddress) {
  9         phishableContract = _phishableContract;
 10         attacker = _attackerAddress;
 11     }
 12 
 13     function () payable {
 14         phishableContract.withdrawAll(attacker);
 15     }
 16 }
----

攻击者可能将此合约伪装成自己的私人地址，并对受害人（ +Phishable+ 合约的所有者）进行社交推广，以将某种形式的交易发送到该地址-也许向该合约发送了一定数量的以太币。除非小心，否则受害者可能不会注意到攻击者的地址上有代码，或者攻击者可能会将其伪装为多签名钱包或某些高级存储钱包（请记住默认情况下，公共合约的源代码不会显示）。

无论如何，如果受害人向 `AttackContract` 的交易地址发送了足够的燃料，它将调用fallback函数，该函数将依次调用 `Phishable` 合约的 `withdrawAll` 函数，传入参数 `attacker`。这将导致 `Phishable` 合约中的所有资金被提现到 `attacker` 地址。这是因为首先初始化调用的地址是受害者（即 `Phishable` 合约的所有者）。因此，`tx.origin` 将等于 `owner`，然后 `Phishable` 合约第11行上的 `require` 条件将被满足。

[role="notoc"]
==== 预防技术

((("tx.origin authentication security threat","preventative techniques")))`tx.origin` 不应用于智能合约中的授权。这并不是说永远不要使用 `tx.origin` 变量。它在智能合约中确实有一些合法的用例。例如，如果开发者想拒绝外部合约调用当前合约，开发者可以设置 `require` 的条件为 `require(tx.origin == msg.sender)`。这样可以防止中间合约被用于调用当前合约，将合约限制为常规的无代码地址(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc49")))。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc2")))

[[contract_libraries_sec]]
=== 合约库

((("security (smart contracts)","contract libraries for")))((("smart contracts","on-platform libraries"))) 有很多可重复使用的现有代码，它们都部署在区块链上作为可调用库，而在链下作为代码模板库。平台上已部署的库以字节码智能合约形式存在，因此在生产中使用它们之前应格外小心。然而，使用完善的现有平台库具有许多优点，例如能够从最新升级中受益，并通过减少以太坊中的实时合约总数为你节省金钱并从以太坊生态系统中受益。

((("frameworks","OpenZeppelin suite")))((("OpenZeppelin")))在以太坊中，使用最广泛的资源是 https://openzeppelin.org/[OpenZeppelin suite]，其中合约的范围从ERC20和ERC721通证的实现到多种类型的众筹模型，再到合约中常见的简单行为，例如 `拥有`， `可暂停` 或 `限制余额`。该存储库中的合约已经过广泛的测试，在某些情况下甚至可以作为事实上的标准实现。它们是免费使用的，由 https://zeppelin.solutions[Zeppelin] 以及越来越多的外部贡献者一起构建和维护。

((("frameworks","ZeppelinOS")))((("ZeppelinOS"))) Zeppelin也是来源于 https://zeppelinos.org/[ZeppelinOS] ，这是一个开源的平台，提供可用于安全地开发和使用智能合约应用程序的服务和工具。 ZeppelinOS在EVM之上提供了一层，使开发人员可以轻松地启动可升级的DApp，这些DApp链接到经过测试的，本身可以升级的合约的链上库。这些库的不同版本可以在以太坊平台上共存，凭证系统允许用户向不同方向提出或推动改进。该平台还提供了一组用于调试，测试，部署和监视分布式应用程序的链下工具。

((("ethpm project"))) +ethpm+ 项目旨在通过提供程序包管理系统来组织生态系统中正在开发的各种资源。因此，其注册表提供了更多示例供你浏览：

* 网站： https://www.ethpm.com/
* 资料库链接： https://www.ethpm.com/registry
* GitHub 链接: https://github.com/ethpm
* 文档： https://www.ethpm.com/docs/integration-guide

=== 结论

任何在智能合约领域工作的开发人员都需要了解和理解很多东西。通过遵循智能合约设计和代码编写中的最佳实践，你将避免许多严重的陷阱和圈套。

也许最基本的软件安全性原则是最大化可信代码的重用。在密码学中，这一点是如此重要，以至于它被浓缩成一句格言：“不要自行加密。”在智能合约的情况下，这等于从社区彻底审查过的免费可用库中获取了尽可能多的收益。(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc1")))(((range="endofrange", startref="ix_09smart-contracts-security-asciidoc0")))